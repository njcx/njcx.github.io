<!DOCTYPE html>
<html lang="zh">

<head>
  <!-- Required meta tags always come first -->
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="google-site-verification" content="GgupatpoZgdqsBlxEZoMqGAy3aXAFtXIrYged3SB6EA" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>NIDS开发之IP分片重组和TCP段重组 | nJcx's Blog
</title>
  <link rel="canonical" href="https://www.njcx.bid/posts/T6.html">


  <link rel="apple-touch-icon" href="https://www.njcx.bid/apple-touch-icon.png" sizes="180x180">
  <link rel="icon" type="image/png" href="https://www.njcx.bid/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://www.njcx.bid/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://www.njcx.bid/manifest.json">
  <meta name="theme-color" content="#333333">

  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/pygments/emacs.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/style.css">


<meta name="description" content="NIDS开发之IP分片重组和TCP段重组 ~">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a34c7a96ae9745547c373575407c521f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</head>

<body>
  <header class="header">
    <div class="container">
      <div class="row">
        <div class="col-sm-4">
          <a href="https://www.njcx.bid">
            <img class="img-fluid" src=https://www.njcx.bid/images/profile.png width=200 height=200 alt="nJcx's Blog">
          </a>
        </div>
        <div class="col-sm-8">
          <h1 class="title">&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="https://www.njcx.bid">nJcx's Blog</a></h1>
          <p class="text-muted">十年生死两茫茫，写程序，到天亮。相顾无言，惟有泪千行</p>
          <ul class="list-inline">
                    <li class="list-inline-item">&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="https://www.zhihu.com/people/njcxs" target="_blank">知乎</a></li>
                <li class="list-inline-item"><a href="https://www.anquanke.com/member/154147" target="_blank">安全客</a></li>
                <li class="list-inline-item"><a href="https://www.freebuf.com/column/1481" target="_blank">Freebuf</a></li>
            <li class=" list-inline-item text-muted">|</li>
            <li class="list-inline-item"><a class="fa fa-github" href="https://github.com/njcx" target="_blank"></a></li>
          </ul>
        </div>
      </div>
    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>NIDS开发之IP分片重组和TCP段重组
</h1>
      <hr>
<article class="article">
  <header>
    <ul class="list-inline">
      <li class="list-inline-item text-muted" title="2024-10-29T20:20:00+03:00">
        <i class="fa fa-clock-o"></i>
        二 29 十月 2024
      </li>
      <li class="list-inline-item">
        <i class="fa fa-folder-open-o"></i>
        <a href="https://www.njcx.bid/category/an-quan.html">安全</a>
      </li>
      <li class="list-inline-item">
        <i class="fa fa-user-o"></i>
        <a href="https://www.njcx.bid/author/njcx.html">nJcx</a>      </li>
      <li class="list-inline-item">
        <i class="fa fa-files-o"></i>
        <a href="https://www.njcx.bid/tag/qi-ye-an-quan-jian-she.html">#企业安全建设</a>      </li>
    </ul>
  </header>
  <div class="content">
    <h4>介绍</h4>
<p>NIDS（Network Intrusion Detection System，网络入侵检测系统）开发过程中，主要拆解成两个部分开发， 第一的DPI深度包解析，第二就是规则引擎。DPI深度包解析是指NIDS通过监听网络流量来捕捉数据包、协议识别、拆解成字段过程。这些数据包包含了从网络的一个点传输到另一个点的信息。DPI是NIDS分析网络活动以检测潜在入侵行为的基础步骤， 捕捉数据包的工具有 libpcap 、PF_RING、DPDK等等。DPI深度包解析工具有PacketBeat、NDPI、Zeek、Suricata等等。</p>
<p>在TCP/IP协议栈中，数据包的重组主要涉及两个方面：IP分片重组和TCP段重组。</p>
<p>IP分片重组：当一个IP数据报由于过大而无法在一个物理网络上进行传输时，它可能会被分成多个较小的片段（分片），每个分片作为一个独立的IP数据报进行传输。这些分片最终需要在目的地处重新组装成原始的数据报。这个过程称为IP分片重组。IP头部包含了一个标识字段、一个标志字段和一个分片偏移字段，它们共同作用以帮助目的主机正确地重组这些分片。</p>
<p>TCP段重组：TCP（传输控制协议）是面向连接的，并提供可靠的数据传输服务。在数据传输过程中，发送方可能会将数据分割成多个TCP段进行发送。因为网络中的路由和延迟不同，这些TCP段可能不会按照它们被发送的顺序到达接收方。TCP使用序列号和确认机制来确保所有发送的数据都能够按照正确的顺序被重组。接收方根据序列号对收到的TCP段进行排序，并在必要时等待丢失段的重传，从而实现数据的正确重组。</p>
<p>为什么NIDS 涉及到IP分片重组和TCP段重组 ？ 这些不是TCP/IP协议栈的事情吗？
因为NIDS使用 libpcap 或者 DPDK， 抓取的都是一帧， 一个IP分片通常被封装成一帧进行传输。 当数据比较大的时候，比如 http post 一个稍大的json， 经过TCP段重组（没有IP分片），才能看到完整的 json。在TCP/IP协议栈中， 每一层对上都是透明的， 而在NIDS 中，每一层都需要自己重组。</p>
<p>IP分片和TCP分段是一回事吗 ？</p>
<p>IP分片和TCP分段不是一回事，它们是发生在网络协议栈不同层次的数据切分机制, 一般不同时发生。具体区别如下：</p>
<div class="highlight"><pre><span></span><code>IP分片：发生在网络层，由IP协议处理，由于网络链路层的MTU（最大传输单元）限制，当IP数据报大小超过MTU时，需要进行分片。
TCP分片：发生在传输层，由TCP协议处理，为了适应MSS（最大分段大小），避免IP层分片，TCP会根据MSS对数据进行分段。
</code></pre></div>
<p>TCP分段是非常常见的，因为几乎所有的HTTP、FTP等基于TCP的应用层协议都依赖于这种机制来传输数据。TCP协议的设计本身就支持这种分段和重组操作，以适应各种网络状况并保证数据传输的可靠性。而IP分片则更多是一种在网络层面上处理特殊情况的机制，理想情况下应该尽量避免，因为它带来的问题比它解决的问题还要多。</p>
<p>IP 分片示例</p>
<p>假设主机 A 要通过以太网向主机 B 发送一个总大小为 <strong>4000 字节</strong>的 IP 数据报。  </p>
<ul>
<li>网络路径的 MTU（最大传输单元）为 <strong>1500 字节</strong>。</li>
<li>IP 首部长度为 <strong>20 字节</strong>。</li>
</ul>
<p>由于数据报的总长度（4000 字节）超过了 MTU（1500 字节），因此需要进行 <strong>IP 分片</strong>。</p>
<p>IP 分片过程</p>
<ol>
<li>
<p>计算 IP 分片数量</p>
</li>
<li>
<p>每个分片的最大有效载荷 1500 - 20(IP首部) = 1480  字节。</p>
</li>
<li>
<p>总数据量为 <strong>4000 字节</strong>，因此需要分成：4000 ÷ 1480  = 3   </p>
</li>
<li>
<p>IP 分片详细信息</p>
</li>
</ol>
<table class="table-hover table-striped table">
<thead>
<tr>
<th>分片编号</th>
<th>数据范围</th>
<th>数据长度</th>
<th>偏移量（字节）</th>
<th>偏移量（单位）</th>
<th>MF 标志位</th>
<th>总长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>第 1 片</td>
<td>0 ~ 1479</td>
<td>1480</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1500</td>
</tr>
<tr>
<td>第 2 片</td>
<td>1480 ~ 2959</td>
<td>1480</td>
<td>1480</td>
<td>185</td>
<td>1</td>
<td>1500</td>
</tr>
<tr>
<td>第 3 片</td>
<td>2960 ~ 3999</td>
<td>1040</td>
<td>2960</td>
<td>370</td>
<td>0</td>
<td>1060</td>
</tr>
</tbody>
</table>
<blockquote class="blockquote">
<p><strong>偏移量单位说明</strong>: 偏移量是以 <strong>8 字节</strong> 为单位计算的，因此实际偏移量需要除以 8。</p>
</blockquote>
<p>分片的具体内容</p>
<p>第 1 片</p>
<ul>
<li><strong>标识符</strong>: 12345</li>
<li><strong>MF 标志位</strong>: 1 （表示还有后续分片）</li>
<li><strong>偏移量</strong>: 0</li>
<li><strong>数据负载</strong>: 前 1480 字节的数据</li>
<li><strong>总长度</strong>: 1500 字节（1480 + 20）</li>
</ul>
<p>第 2 片</p>
<ul>
<li><strong>标识符</strong>: 12345</li>
<li><strong>MF 标志位</strong>: 1 （表示还有后续分片）</li>
<li><strong>偏移量</strong>: 185 （1480 ÷ 8 = 185）</li>
<li><strong>数据负载</strong>: 接下来的 1480 字节的数据</li>
<li><strong>总长度</strong>: 1500 字节（1480 + 20）</li>
</ul>
<p>第 3 片</p>
<ul>
<li><strong>标识符</strong>: 12345</li>
<li><strong>MF 标志位</strong>: 0 （表示这是最后一个分片）</li>
<li><strong>偏移量</strong>: 370 （2960 ÷ 8 = 370）</li>
<li><strong>数据负载</strong>: 最后的 1040 字节的数据</li>
<li><strong>总长度</strong>: 1060 字节（1040 + 20）</li>
</ul>
<p>重组过程</p>
<p>当主机 B 收到这些分片时：</p>
<ol>
<li>主机 B 根据 <strong>标识符</strong> 来确定这些分片属于同一个原始数据报。</li>
<li>根据 <strong>偏移量</strong> 和 <strong>MF 标志位</strong>，将所有分片按顺序拼接起来。</li>
<li>重组后的数据报与原始数据报完全相同，包含 <strong>4000 字节</strong> 的数据。</li>
</ol>
<p>通过这个例子可以清楚地看到：</p>
<ul>
<li><strong>IP 分片</strong> 是基于网络路径的 MTU 进行的，确保每个分片的总长度不超过 MTU。</li>
<li>主机 B 通过 <strong>标识符</strong>、<strong>偏移量</strong> 和 <strong>MF 标志位</strong>，能够准确地将分片重组为原始数据报。</li>
</ul>
<p>TCP 分段示例</p>
<p>假设主机 A 要通过以太网向主机 B 发送一个总大小为 <strong>4000 字节</strong>的应用层数据。  </p>
<ul>
<li>网络路径的 MTU（最大传输单元）为 <strong>1500 字节</strong>。</li>
<li>TCP 的 MSS（最大分段大小）协商后为 <strong>1460 字节</strong>（即 1500 - 20(IP首部) - 20(TCP首部)）。</li>
<li>IP 首部长度为 <strong>20 字节</strong>。</li>
</ul>
<p>由于应用层数据的大小超过了 MSS 的限制，因此需要进行 <strong>TCP 分段</strong>。</p>
<p>TCP 分段过程</p>
<ol>
<li>
<p>计算 TCP 分段数量</p>
<ul>
<li>每个 TCP 数据段的最大有效载荷为 <strong>1460 字节</strong>。</li>
<li>总数据量为 <strong>4000 字节</strong>，因此需要分成：
   4000 ÷ 1460  = 3  </li>
</ul>
</li>
<li>
<p>TCP 分段详细信息</p>
</li>
</ol>
<table class="table-hover table-striped table">
<thead>
<tr>
<th>分段编号</th>
<th>序列号范围</th>
<th>数据长度</th>
<th>TCP 首部长度</th>
<th>IP 首部长度</th>
<th>总长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>第 1 段</td>
<td>1 ~ 1460</td>
<td>1460</td>
<td>20</td>
<td>20</td>
<td>1500</td>
</tr>
<tr>
<td>第 2 段</td>
<td>1461 ~ 2920</td>
<td>1460</td>
<td>20</td>
<td>20</td>
<td>1500</td>
</tr>
<tr>
<td>第 3 段</td>
<td>2921 ~ 4000</td>
<td>1080</td>
<td>20</td>
<td>20</td>
<td>1120</td>
</tr>
</tbody>
</table>
<p>重组过程</p>
<p>当主机 B 收到这些分段时：</p>
<ol>
<li>主机 B 根据 <strong>TCP 序列号</strong> 将所有分段按顺序拼接起来。</li>
<li>最终得到完整的 <strong>4000 字节</strong> 数据，并交给应用层。</li>
</ol>
<p>通过这个例子可以清楚地看到：</p>
<ul>
<li><strong>TCP 分段</strong> 是基于 MSS 进行的，确保每个分段的总长度不超过 MTU。</li>
<li>主机 B 通过 <strong>TCP 序列号</strong>，能够准确地将分段重组为原始数据。</li>
<li>在本例中，由于网络路径的 MTU 为 1500 字节，且 MSS 为 1460 字节，因此无需进行 IP 分片。</li>
</ul>
<h4>IP分片重组</h4>
<p>我们看一下, Suricata 是怎么处理IP分片重组的:</p>
<p>1,核心数据结构:</p>
<div class="highlight"><pre><span></span><code>//<span class="w"> </span>defrag.h<span class="w"> </span>-<span class="w"> </span>分片重组的主要数据结构
typedef<span class="w"> </span>struct<span class="w"> </span>DefragTracker_<span class="w"> </span><span class="o">{</span>
<span class="w">    </span>SCMutex<span class="w"> </span>lock<span class="p">;</span><span class="w">        </span>//<span class="w"> </span>互斥锁保护
<span class="w">    </span>uint32_t<span class="w"> </span>id<span class="p">;</span><span class="w">         </span>//<span class="w"> </span>IP<span class="w"> </span>包<span class="w"> </span>ID
<span class="w">    </span>uint8_t<span class="w"> </span>proto<span class="p">;</span><span class="w">       </span>//<span class="w"> </span>IP<span class="w"> </span>协议
<span class="w">    </span>uint8_t<span class="w"> </span>policy<span class="p">;</span><span class="w">      </span>//<span class="w"> </span>重组策略
<span class="w">    </span>uint8_t<span class="w"> </span>af<span class="p">;</span><span class="w">          </span>//<span class="w"> </span>地址族<span class="o">(</span>IPv4/IPv6<span class="o">)</span>
<span class="w">    </span>uint8_t<span class="w"> </span>seen_last<span class="p">;</span><span class="w">   </span>//<span class="w"> </span>是否看到最后一个分片
<span class="w">    </span>Address<span class="w"> </span>src_addr<span class="p">;</span><span class="w">    </span>//<span class="w"> </span>源地址
<span class="w">    </span>Address<span class="w"> </span>dst_addr<span class="p">;</span><span class="w">    </span>//<span class="w"> </span>目的地址
<span class="w">    </span>struct<span class="w"> </span>IP_FRAGMENTS<span class="w"> </span>fragment_tree<span class="p">;</span><span class="w"> </span>//<span class="w"> </span>分片树
<span class="o">}</span><span class="w"> </span>DefragTracker<span class="p">;</span>

//<span class="w"> </span>单个分片的结构
typedef<span class="w"> </span>struct<span class="w"> </span>Frag_<span class="w"> </span><span class="o">{</span>
<span class="w">    </span>uint16_t<span class="w"> </span>offset<span class="p">;</span><span class="w">     </span>//<span class="w"> </span>分片偏移<span class="w"> </span>
<span class="w">    </span>uint32_t<span class="w"> </span>len<span class="p">;</span><span class="w">        </span>//<span class="w"> </span>分片长度
<span class="w">    </span>uint8_t<span class="w"> </span>more_frags<span class="p">;</span><span class="w">  </span>//<span class="w"> </span>是否还有更多分片
<span class="w">    </span>uint8_t<span class="w"> </span>*pkt<span class="p">;</span><span class="w">        </span>//<span class="w"> </span>实际分片数据
<span class="w">    </span>RB_ENTRY<span class="o">(</span>Frag_<span class="o">)</span><span class="w"> </span>rb<span class="p">;</span><span class="w">  </span>//<span class="w"> </span>红黑树节点
<span class="o">}</span><span class="w"> </span>Frag<span class="p">;</span>
</code></pre></div>
<p>2, 重组流程:</p>
<div class="highlight"><pre><span></span><code>//<span class="w"> </span>decode-ipv4.c<span class="w"> </span>中的处理流程
int<span class="w"> </span>DecodeIPV4<span class="o">(</span>ThreadVars<span class="w"> </span>*tv,<span class="w"> </span>DecodeThreadVars<span class="w"> </span>*dtv,<span class="w"> </span>Packet<span class="w"> </span>*p,<span class="w"> </span>const<span class="w"> </span>uint8_t<span class="w"> </span>*pkt,<span class="w"> </span>uint16_t<span class="w"> </span>len<span class="o">)</span>
<span class="o">{</span>
<span class="w">    </span>//<span class="w"> </span><span class="m">1</span>.<span class="w"> </span>检测到分片标记
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>IPV4_GET_RAW_FRAGOFFSET<span class="o">(</span>ip4h<span class="o">)</span><span class="w"> </span>&gt;<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>IPV4_GET_RAW_FLAG_MF<span class="o">(</span>ip4h<span class="o">))</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>//<span class="w"> </span><span class="m">2</span>.<span class="w"> </span>调用<span class="w"> </span>Defrag<span class="w"> </span>进行重组
<span class="w">        </span>Packet<span class="w"> </span>*rp<span class="w"> </span><span class="o">=</span><span class="w"> </span>Defrag<span class="o">(</span>tv,<span class="w"> </span>dtv,<span class="w"> </span>p<span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>rp<span class="w"> </span>!<span class="o">=</span><span class="w"> </span>NULL<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">            </span>//<span class="w"> </span><span class="m">3</span>.<span class="w"> </span>重组成功,将重组后的包加入队列
<span class="w">            </span>PacketEnqueueNoLock<span class="o">(</span><span class="p">&amp;</span>tv-&gt;decode_pq,<span class="w"> </span>rp<span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="o">}</span>
<span class="w">        </span>p-&gt;flags<span class="w"> </span><span class="p">|</span><span class="o">=</span><span class="w"> </span>PKT_IS_FRAGMENT<span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span>TM_ECODE_OK<span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>IPv4 通过检查分片偏移(Fragment Offset)和 More Fragments 标志位识别分片, IPv6 通过分片扩展头(Fragment Extension Header)识别分片. 使用红黑树存储各个分片, 按照偏移量排序, 通过 DefragTracker 跟踪同一数据包的所有分片, 设置超时机制避免资源耗尽.</p>
<p>重要函数:</p>
<div class="highlight"><pre><span></span><code>//<span class="w"> </span>分片重组的主函数
Packet<span class="w"> </span>*Defrag<span class="o">(</span>ThreadVars<span class="w"> </span>*tv,<span class="w"> </span>DecodeThreadVars<span class="w"> </span>*dtv,<span class="w"> </span>Packet<span class="w"> </span>*p<span class="o">)</span><span class="w"> </span>
<span class="o">{</span>
<span class="w">    </span>//<span class="w"> </span><span class="m">1</span>.<span class="w"> </span>创建/查找分片追踪器
<span class="w">    </span>//<span class="w"> </span><span class="m">2</span>.<span class="w"> </span>将分片加入分片树
<span class="w">    </span>//<span class="w"> </span><span class="m">3</span>.<span class="w"> </span>检查是否可以重组
<span class="w">    </span>//<span class="w"> </span><span class="m">4</span>.<span class="w"> </span>重组分片生成新包
<span class="w">    </span>//<span class="w"> </span><span class="m">5</span>.<span class="w"> </span>返回重组后的包
<span class="o">}</span>

//<span class="w"> </span>处理<span class="w"> </span>IPv6<span class="w"> </span>分片头
void<span class="w"> </span>DecodeIPV6FragHeader<span class="o">(</span>Packet<span class="w"> </span>*p,<span class="w"> </span>const<span class="w"> </span>uint8_t<span class="w"> </span>*pkt,<span class="w"> </span>uint16_t<span class="w"> </span>hdrextlen,<span class="w"> </span>
<span class="w">                         </span>uint16_t<span class="w"> </span>plen,<span class="w"> </span>uint16_t<span class="w"> </span>prev_hdrextlen<span class="o">)</span>
<span class="o">{</span>
<span class="w">    </span>//<span class="w"> </span>解析分片头
<span class="w">    </span>//<span class="w"> </span>设置分片标记
<span class="w">    </span>//<span class="w"> </span>进行合法性检查
<span class="o">}</span>
</code></pre></div>
<p>所以总的来说,Suricata 的 IP 分片重组实现主要基于:</p>
<div class="highlight"><pre><span></span><code>使用分片跟踪器(DefragTracker)和分片树管理分片
支持 IPv4 和 IPv6 协议
有完善的错误检测机制
通过队列管理重组后的包
采用互斥锁保证线程安全
这个实现比较完整地覆盖了 IP 分片重组的各个方面,包括分片识别、存储、重组、验证等环节。
</code></pre></div>
<h4>TCP段重组</h4>
<p>Zeek 中 TCP 分段重组的实现:</p>
<p>1.核心数据结构</p>
<div class="highlight"><pre><span></span><code>//<span class="w"> </span>src/analyzer/protocol/tcp/TCP_Reassembler.h
//<span class="w"> </span>TCP_Reassembler<span class="w"> </span>类
class<span class="w"> </span>TCP_Reassembler<span class="w"> </span>final<span class="w"> </span>:<span class="w"> </span>public<span class="w"> </span>Reassembler<span class="w"> </span><span class="o">{</span>
<span class="w">    </span>enum<span class="w"> </span>Type<span class="w"> </span><span class="o">{</span>
<span class="w">        </span>Direct,<span class="w">  </span>//<span class="w"> </span>直接传递到目标分析器<span class="w"> </span>
<span class="w">        </span>Forward<span class="w">  </span>//<span class="w"> </span>转发到目标分析器的子节点
<span class="w">    </span><span class="o">}</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span>TCP_Endpoint*<span class="w"> </span>endp<span class="p">;</span><span class="w">        </span>//<span class="w"> </span>TCP<span class="w"> </span>端点
<span class="w">    </span>bool<span class="w"> </span>had_gap<span class="p">;</span><span class="w">             </span>//<span class="w"> </span>是否有数据空洞
<span class="w">    </span>bool<span class="w"> </span>deliver_tcp_contents<span class="p">;</span><span class="w"> </span>//<span class="w"> </span>是否传递TCP内容
<span class="w">    </span>uint64_t<span class="w"> </span>seq_to_skip<span class="p">;</span><span class="w">     </span>//<span class="w"> </span>要跳过的序列号
<span class="w">    </span>FilePtr<span class="w"> </span>record_contents_file<span class="p">;</span><span class="w"> </span>//<span class="w"> </span>记录内容的文件
<span class="o">}</span><span class="p">;</span>

//<span class="w"> </span>src/packet_analysis/protocol/tcp/TCPSessionAdapter.h
//<span class="w"> </span>TCPSessionAdapter<span class="w"> </span>类
class<span class="w"> </span>TCPSessionAdapter<span class="w"> </span><span class="o">{</span>
<span class="w">    </span>TCP_Endpoint*<span class="w"> </span>orig<span class="p">;</span><span class="w">         </span>//<span class="w"> </span>发起方端点
<span class="w">    </span>TCP_Endpoint*<span class="w"> </span>resp<span class="p">;</span><span class="w">         </span>//<span class="w"> </span>响应方端点
<span class="w">    </span>bool<span class="w"> </span>reassembling<span class="p">;</span><span class="w">          </span>//<span class="w"> </span>是否正在重组
<span class="w">    </span>bool<span class="w"> </span>is_partial<span class="p">;</span><span class="w">            </span>//<span class="w"> </span>是否部分连接
<span class="w">    </span>uint64_t<span class="w"> </span>rel_data_seq<span class="p">;</span><span class="w">      </span>//<span class="w"> </span>相对数据序列号
<span class="o">}</span><span class="p">;</span>
</code></pre></div>
<p>2, 重组流程</p>
<div class="highlight"><pre><span></span><code>//<span class="w"> </span>启用重组:
void<span class="w"> </span>TCPSessionAdapter::EnableReassembly<span class="o">()</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>SetReassembler<span class="o">(</span>
<span class="w">        </span>new<span class="w"> </span>TCP_Reassembler<span class="o">(</span>this,<span class="w"> </span>TCP_Reassembler::Forward,<span class="w"> </span>orig<span class="o">)</span>,
<span class="w">        </span>new<span class="w"> </span>TCP_Reassembler<span class="o">(</span>this,<span class="w"> </span>TCP_Reassembler::Forward,<span class="w"> </span>resp<span class="o">)</span>
<span class="w">    </span><span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

//<span class="w"> </span>数据到达处理:
//<span class="w"> </span>src/analyzer/protocol/tcp/TCP_Reassembler.cc<span class="w"> </span>-<span class="w"> </span>TCP<span class="w"> </span>重组器实现

void<span class="w"> </span>TCP_Reassembler::DataSent<span class="o">(</span>double<span class="w"> </span>t,<span class="w"> </span>uint64_t<span class="w"> </span>seq,<span class="w"> </span>int<span class="w"> </span>len,<span class="w"> </span>
<span class="w">                              </span>const<span class="w"> </span>u_char*<span class="w"> </span>data<span class="o">)</span><span class="w"> </span><span class="o">{</span>

<span class="w">    </span>//<span class="w"> </span>检查是否需要跳过
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>IsSkippedContents<span class="o">(</span>seq,<span class="w"> </span>len<span class="o">))</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span>//<span class="w"> </span>处理数据空洞
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>seq<span class="w"> </span>&gt;<span class="w"> </span>last_reassem_seq<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>Gap<span class="o">(</span>last_reassem_seq,<span class="w"> </span>seq<span class="w"> </span>-<span class="w"> </span>last_reassem_seq<span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="nv">had_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>true<span class="p">;</span>
<span class="w">    </span><span class="o">}</span>

<span class="w">    </span>//<span class="w"> </span>交付数据
<span class="w">    </span>DeliverBlock<span class="o">(</span>seq,<span class="w"> </span>len,<span class="w"> </span>data<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

//<span class="w"> </span>src/packet_analysis/protocol/tcp/TCPSessionAdapter.cc
void<span class="w"> </span>TCPSessionAdapter::Process<span class="o">(</span>bool<span class="w"> </span>is_orig,<span class="w"> </span>const<span class="w"> </span>struct<span class="w"> </span>tcphdr*<span class="w"> </span>tp,
<span class="w">                              </span>int<span class="w"> </span>len,<span class="w"> </span>const<span class="w"> </span>IP_Hdr*<span class="w"> </span>ip<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>//<span class="w"> </span>获取序列号<span class="w">    </span>
<span class="w">    </span>uint32_t<span class="w"> </span><span class="nv">base_seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ntohl<span class="o">(</span>tp-&gt;th_seq<span class="o">)</span><span class="p">;</span>

<span class="w">    </span>//<span class="w"> </span>处理标志位
<span class="w">    </span>TCP_Flags<span class="w"> </span>flags<span class="o">(</span>tp<span class="o">)</span><span class="p">;</span>

<span class="w">    </span>//<span class="w"> </span>分析状态
<span class="w">    </span>UpdateStateMachine<span class="o">(</span>t,<span class="w"> </span>endpoint,<span class="w"> </span>peer,<span class="w"> </span>base_seq,<span class="w"> </span>flags<span class="o">)</span><span class="p">;</span><span class="w"> </span>

<span class="w">    </span>//<span class="w"> </span>数据重组
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>len<span class="w"> </span>&gt;<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>!flags.RST<span class="o">())</span>
<span class="w">        </span>endpoint-&gt;DataSent<span class="o">(</span>t,<span class="w"> </span>base_seq,<span class="w"> </span>len,<span class="w"> </span>data<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>



//<span class="w">  </span>空洞处理:
void<span class="w"> </span>TCP_Reassembler::Gap<span class="o">(</span>uint64_t<span class="w"> </span>seq,<span class="w"> </span>uint64_t<span class="w"> </span>len<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>//<span class="w"> </span>报告空洞
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>report_gap<span class="o">(</span>endp,<span class="w"> </span>endp-&gt;peer<span class="o">))</span>
<span class="w">        </span>dst_analyzer-&gt;EnqueueConnEvent<span class="o">(</span>content_gap,<span class="w"> </span>...<span class="o">)</span><span class="p">;</span>

<span class="w">    </span>//<span class="w"> </span>更新状态
<span class="w">    </span><span class="nv">had_gap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>true<span class="p">;</span>
<span class="o">}</span>


//<span class="w"> </span>跟踪<span class="w"> </span>TCP<span class="w"> </span>状态:
void<span class="w"> </span>TCPSessionAdapter::UpdateStateMachine<span class="o">(</span>TCP_Endpoint*<span class="w"> </span>endpoint,
<span class="w">    </span>TCP_Endpoint*<span class="w"> </span>peer,<span class="w"> </span>uint32_t<span class="w"> </span>seq,<span class="w"> </span>TCP_Flags<span class="w"> </span>flags<span class="o">)</span>
<span class="o">{</span>
<span class="w">    </span>//<span class="w"> </span>SYN<span class="w"> </span>处理
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>flags.SYN<span class="o">())</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>is_orig<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">            </span>endpoint-&gt;SetState<span class="o">(</span>TCP_ENDPOINT_SYN_SENT<span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="o">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="o">{</span>
<span class="w">            </span>endpoint-&gt;SetState<span class="o">(</span>TCP_ENDPOINT_ESTABLISHED<span class="o">)</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="o">}</span>
<span class="w">    </span><span class="o">}</span>

<span class="w">    </span>//<span class="w"> </span>FIN<span class="w"> </span>处理<span class="w">  </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>flags.FIN<span class="o">())</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>endpoint-&gt;SetState<span class="o">(</span>TCP_ENDPOINT_CLOSED<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="o">}</span>

<span class="w">    </span>//<span class="w"> </span>RST<span class="w"> </span>处理
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>flags.RST<span class="o">())</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>endpoint-&gt;SetState<span class="o">(</span>TCP_ENDPOINT_RESET<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Zeek 使用两个主要组件来处理 TCP 分段重组:</p>
<div class="highlight"><pre><span></span><code>    TCP_Reassembler: 专门负责重组的核心组件
    TCPSessionAdapter: 管理整个 TCP 会话的组件
</code></pre></div>
<p>就像是一个拼图游戏,TCP_Reassembler 负责把所有碎片(TCP分段)拼在一起,而 TCPSessionAdapter 则像是一个总管理员,负责监督整个拼图过程。</p>
<p>当一个 TCP 包到达时,处理流程是:</p>
<div class="highlight"><pre><span></span><code>数据排序
检查序列号是否连续
如果是期望的下一个序列号,直接处理
如果不是,放入缓存等待处理
空洞处理
当发现序列号不连续时,记录为"空洞"
继续接收后续数据,等待空洞被填补
</code></pre></div>
<p>Zeek 使用几个关键机制来管理数据:</p>
<div class="highlight"><pre><span></span><code>序列号跟踪
记录已处理的最后序列号
检查新数据的序列号是否符合预期
缓存管理
对乱序到达的数据进行缓存
定期清理过期的缓存数据
状态跟踪
跟踪连接状态(SYN, FIN, RST等)
根据状态决定如何处理数据
</code></pre></div>
<p>想象你在收集一系列明信片(TCP分段):</p>
<div class="highlight"><pre><span></span><code>每张明信片都有序号(序列号)
你需要按顺序排列它们才能看到完整图片
有时候明信片到达的顺序是乱的(乱序数据)
有时候有明信片丢失了(数据空洞)
你需要等待缺失的明信片(填补空洞)
最后将所有明信片按顺序排好(重组完成)
</code></pre></div>
<p>Zeek 就是在做类似的工作,但是它同时在处理两个方向的"明信片集",而且速度要快得多。
这种实现方式既保证了数据的完整性和正确性,又提供了足够的灵活性和性能,使得 Zeek 能够有效地分析网络流量。</p>
<h4>Demo</h4>
<div class="highlight"><pre><span></span><code>//<span class="w"> </span>TCP<span class="w"> </span>流结构
typedef<span class="w"> </span>struct<span class="w"> </span><span class="o">{</span>
<span class="w">    </span>uint32_t<span class="w"> </span>src_ip<span class="p">;</span>
<span class="w">    </span>uint32_t<span class="w"> </span>dst_ip<span class="p">;</span>
<span class="w">    </span>uint16_t<span class="w"> </span>src_port<span class="p">;</span>
<span class="w">    </span>uint16_t<span class="w"> </span>dst_port<span class="p">;</span>
<span class="w">    </span>uint32_t<span class="w"> </span>next_seq<span class="p">;</span><span class="w">    </span>//<span class="w"> </span>关键字段：下一个期望的序列号
<span class="w">    </span>uint32_t<span class="w"> </span>init_seq<span class="p">;</span><span class="w">    </span>//<span class="w"> </span>初始序列号
<span class="w">    </span>time_t<span class="w"> </span>last_seen<span class="p">;</span>
<span class="w">    </span>unsigned<span class="w"> </span>char<span class="w"> </span>*stream<span class="p">;</span><span class="w">  </span>//<span class="w"> </span>存储重组数据的缓冲区
<span class="w">    </span>int<span class="w"> </span>stream_size<span class="p">;</span><span class="w">       </span>//<span class="w"> </span>当前已重组的数据大小
<span class="w">    </span>flow_state<span class="w"> </span>state<span class="p">;</span>
<span class="w">    </span>char<span class="w"> </span>src_ip_str<span class="o">[</span>INET_ADDRSTRLEN<span class="o">]</span><span class="p">;</span>
<span class="w">    </span>char<span class="w"> </span>dst_ip_str<span class="o">[</span>INET_ADDRSTRLEN<span class="o">]</span><span class="p">;</span>
<span class="o">}</span><span class="w"> </span>tcp_flow_t<span class="p">;</span>

//<span class="w"> </span>全局变量
tcp_flow_t<span class="w"> </span>flows<span class="o">[</span>MAX_FLOWS<span class="o">]</span><span class="p">;</span>
int<span class="w"> </span><span class="nv">flow_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>void<span class="w"> </span>handle_tcp_packet<span class="o">(</span>const<span class="w"> </span>struct<span class="w"> </span>ip<span class="w"> </span>*ip_header,<span class="w"> </span>const<span class="w"> </span>struct<span class="w"> </span>tcphdr<span class="w"> </span>*tcp_header,
<span class="w">                       </span>const<span class="w"> </span>unsigned<span class="w"> </span>char<span class="w"> </span>*payload,<span class="w"> </span>int<span class="w"> </span>payload_len<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span>tcp_flow_t<span class="w"> </span>*flow<span class="w"> </span><span class="o">=</span><span class="w"> </span>find_or_create_flow<span class="o">(</span>ip_header,<span class="w"> </span>tcp_header<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>!flow<span class="o">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>tcp_header-&gt;th_flags<span class="w"> </span><span class="p">&amp;</span><span class="w"> </span>TH_SYN<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>flow-&gt;state<span class="w"> </span><span class="o">==</span><span class="w"> </span>FLOW_NEW<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">            </span>flow-&gt;state<span class="w"> </span><span class="o">=</span><span class="w"> </span>FLOW_ESTABLISHED<span class="p">;</span>
<span class="w">            </span>flow-&gt;next_seq<span class="w"> </span><span class="o">=</span><span class="w"> </span>ntohl<span class="o">(</span>tcp_header-&gt;th_seq<span class="o">)</span><span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="p">;</span><span class="w">  </span>//<span class="w"> </span>SYN包，序列号+1
<span class="w">            </span>print_flow_info<span class="o">(</span>flow,<span class="w"> </span><span class="s2">"SYN"</span><span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="o">}</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>tcp_header-&gt;th_flags<span class="w"> </span><span class="p">&amp;</span><span class="w"> </span>TH_FIN<span class="w"> </span><span class="o">||</span><span class="w"> </span>tcp_header-&gt;th_flags<span class="w"> </span><span class="p">&amp;</span><span class="w"> </span>TH_RST<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>flow-&gt;state<span class="w"> </span><span class="o">=</span><span class="w"> </span>FLOW_CLOSED<span class="p">;</span>
<span class="w">        </span>print_flow_info<span class="o">(</span>flow,<span class="w"> </span>tcp_header-&gt;th_flags<span class="w"> </span><span class="p">&amp;</span><span class="w"> </span>TH_FIN<span class="w"> </span>?<span class="w"> </span><span class="s2">"FIN"</span><span class="w"> </span>:<span class="w"> </span><span class="s2">"RST"</span><span class="o">)</span><span class="p">;</span>
<span class="w">        </span>process_stream_data<span class="o">(</span>flow<span class="o">)</span><span class="p">;</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>payload_len<span class="w"> </span>&gt;<span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span>uint32_t<span class="w"> </span><span class="nv">seq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>ntohl<span class="o">(</span>tcp_header-&gt;th_seq<span class="o">)</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="nv">seq</span><span class="w"> </span><span class="o">==</span><span class="w"> </span>flow-&gt;next_seq<span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="w">  </span>//<span class="w"> </span>关键重组逻辑：检查序列号是否符合预期
<span class="w">            </span>//<span class="w"> </span>确保不会超出缓冲区
<span class="w">            </span>int<span class="w"> </span><span class="nv">copy_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>payload_len<span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>flow-&gt;stream_size<span class="w"> </span>+<span class="w"> </span>copy_len<span class="w"> </span>&gt;<span class="w"> </span>MAX_STREAM_SIZE<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">                </span><span class="nv">copy_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>MAX_STREAM_SIZE<span class="w"> </span>-<span class="w"> </span>flow-&gt;stream_size<span class="p">;</span>
<span class="w">            </span><span class="o">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>copy_len<span class="w"> </span>&gt;<span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">                </span>//<span class="w"> </span>按序复制数据到重组缓冲区
<span class="w">                </span>memcpy<span class="o">(</span>flow-&gt;stream<span class="w"> </span>+<span class="w"> </span>flow-&gt;stream_size,<span class="w"> </span>payload,<span class="w"> </span>copy_len<span class="o">)</span><span class="p">;</span>
<span class="w">                </span>flow-&gt;stream_size<span class="w"> </span>+<span class="o">=</span><span class="w"> </span>copy_len<span class="p">;</span>
<span class="w">                </span>flow-&gt;next_seq<span class="w"> </span><span class="o">=</span><span class="w"> </span>seq<span class="w"> </span>+<span class="w"> </span>copy_len<span class="p">;</span><span class="w">  </span>//<span class="w"> </span>更新下一个期望的序列号
<span class="w">                </span>flow-&gt;state<span class="w"> </span><span class="o">=</span><span class="w"> </span>FLOW_DATA<span class="p">;</span>
<span class="w">                </span>print_flow_info<span class="o">(</span>flow,<span class="w"> </span><span class="s2">"DATA"</span><span class="o">)</span><span class="p">;</span>
<span class="w">            </span><span class="o">}</span>
<span class="w">        </span><span class="o">}</span>
<span class="w">    </span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>实现了基本的流跟踪功能, 序列号检查, 按序重组数据, 状态跟踪（SYN, FIN, RST等）</p>
<p>代码在这里:</p>
<p>https://github.com/njcx/pcap_tcp_reassemble</p>
  </div>
</article>
<div id="cyReward" role="cylabs" data-use="reward" style="text-align:center;"></div>
<!--PC和WAP自适应版-->
<div id="SOHUCS" ></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cysYUIjwy'; 
var conf = 'prod_71b5e53cad0d27b5ed44fa5219b069b5'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

<script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cysYUIjwy"></script>    </div>
  </div>

  <footer class="footer">
    <div class="container">
      <div class="row">
       <ul class="col-sm-6 list-inline">
          <li class="list-inline-item"><a href="https://www.njcx.bid/authors.html">Authors</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/archives.html">Archives</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/categories.html">Categories</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/tags.html">Tags</a></li>
        </ul>
        <p class="col-sm-6 text-sm-right text-muted">
          本站由 <a href="https://github.com/getpelican/pelican" target="_blank">Pelican 生成</a> 后续 by <a href="https://github.com/njcx" target="_blank">nJcx</a>
        </p>
      </div>
    </div>
  </footer>
</body>

</html>