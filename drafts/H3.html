<!DOCTYPE html>
<html lang="zh">

<head>
  <!-- Required meta tags always come first -->
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="google-site-verification" content="GgupatpoZgdqsBlxEZoMqGAy3aXAFtXIrYged3SB6EA" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>golang快速入门 | nJcx's Blog
</title>
  <link rel="canonical" href="https://www.njcx.bid/drafts/H3.html">


  <link rel="apple-touch-icon" href="https://www.njcx.bid/apple-touch-icon.png" sizes="180x180">
  <link rel="icon" type="image/png" href="https://www.njcx.bid/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="https://www.njcx.bid/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="https://www.njcx.bid/manifest.json">
  <meta name="theme-color" content="#333333">

  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/pygments/emacs.min.css">
  <link rel="stylesheet" href="https://www.njcx.bid/theme/css/style.css">


<meta name="description" content="golang学习后，转化成教程，方便大家阅读">
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?a34c7a96ae9745547c373575407c521f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</head>

<body>
  <header class="header">
    <div class="container">
      <div class="row">
        <div class="col-sm-4">
          <a href="https://www.njcx.bid">
            <img class="img-fluid" src=https://www.njcx.bid/images/profile.png width=200 height=200 alt="nJcx's Blog">
          </a>
        </div>
        <div class="col-sm-8">
          <h1 class="title">&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="https://www.njcx.bid">nJcx's Blog</a></h1>
          <p class="text-muted">十年生死两茫茫，写程序，到天亮。相顾无言，惟有泪千行</p>
          <ul class="list-inline">
                    <li class="list-inline-item">&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp<a href="https://www.zhihu.com/people/njcxs" target="_blank">知乎</a></li>
                <li class="list-inline-item"><a href="https://www.anquanke.com/member/154147" target="_blank">安全客</a></li>
                <li class="list-inline-item"><a href="https://www.freebuf.com/column/1481" target="_blank">Freebuf</a></li>
            <li class=" list-inline-item text-muted">|</li>
            <li class="list-inline-item"><a class="fa fa-github" href="https://github.com/njcx" target="_blank"></a></li>
          </ul>
        </div>
      </div>
    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>golang快速入门
</h1>
      <hr>
<article class="article">
  <header>
    <ul class="list-inline">
      <li class="list-inline-item text-muted" title="2018-06-02T13:20:00+03:00">
        <i class="fa fa-clock-o"></i>
        六 02 六月 2018
      </li>
      <li class="list-inline-item">
        <i class="fa fa-folder-open-o"></i>
        <a href="https://www.njcx.bid/category/bian-cheng-yu-yan.html">编程语言</a>
      </li>
      <li class="list-inline-item">
        <i class="fa fa-user-o"></i>
        <a href="https://www.njcx.bid/author/njcx.html">nJcx</a>      </li>
      <li class="list-inline-item">
        <i class="fa fa-files-o"></i>
        <a href="https://www.njcx.bid/tag/golang.html">#golang</a>      </li>
    </ul>
  </header>
  <div class="content">
    <h5>介绍</h5>
<p>Go语言是谷歌与09年开源的一门编译型编程语言，其专门针对多处理器系统应用程序的编程进行了优化，支持并行进程，自动垃圾回收。Docker就是go语言所编写。</p>
<h4>安装</h4>
<p>mac 电脑安装</p>
<div class="highlight"><pre><span></span><code>brew install golang
</code></pre></div>
<p>ubuntu</p>
<div class="highlight"><pre><span></span><code>sudo apt-get install golang -y
</code></pre></div>
<p>CentOS </p>
<div class="highlight"><pre><span></span><code>yum install golang -y
</code></pre></div>
<h4>向世界打招呼</h4>
<div class="highlight"><pre><span></span><code>package main 

import <span class="s2">"fmt"</span>

func main<span class="o">()</span> <span class="o">{</span>
    fmt.Println<span class="o">(</span><span class="s2">"Hello world!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<h4>注释</h4>
<div class="highlight"><pre><span></span><code>// 单行注释

/*
 我是多行注释
 我是多行注释
 我是多行注释
 我是多行注释
 我是多行注释
 */
</code></pre></div>
<h4>数据结构</h4>
<ul>
<li>布尔型</li>
</ul>
<div class="highlight"><pre><span></span><code>    var b <span class="nv">bool</span> <span class="o">=</span> <span class="nb">true</span>
    c :<span class="o">=</span> <span class="nb">false</span>
</code></pre></div>
<ul>
<li>数字类型
整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，支持复数，位运算采用补码。<ul>
<li>uint8
无符号 8 位整型 (0 到 255)</li>
<li>uint16
  无符号 16 位整型 (0 到 65535)</li>
<li>uint32
无符号 32 位整型 (0 到 4294967295)</li>
<li>uint64
无符号 64 位整型 (0 到 18446744073709551615)</li>
<li>int8
有符号 8 位整型 (-128 到 127)</li>
<li>int16
有符号 16 位整型 (-32768 到 32767)</li>
<li>int32
有符号 32 位整型 (-2147483648 到 2147483647)</li>
<li>int64
有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</li>
<li>float32
IEEE-754 32位浮点型数</li>
<li>float64
IEEE-754 64位浮点型数</li>
<li>complex64
32 位实数和虚数</li>
<li>complex128
64 位实数和虚数</li>
<li>byte
类似 uint8</li>
<li>rune
类似 int32</li>
<li>uint
32 或 64 位</li>
<li>int
与 uint 一样大小</li>
<li>uintptr
无符号整型，用于存放一个指针</li>
</ul>
</li>
</ul>
<p>变量</p>
<div class="highlight"><pre><span></span><code>var <span class="nv">a</span> <span class="o">=</span> <span class="m">1</span>

var b <span class="nv">int</span> <span class="o">=</span> <span class="m">2</span>

c :<span class="o">=</span><span class="m">3</span>
</code></pre></div>
<p>常量</p>
<div class="highlight"><pre><span></span><code>const identifier <span class="o">[</span>type<span class="o">]</span> <span class="o">=</span> value

显式类型定义： const b <span class="nv">string</span> <span class="o">=</span> <span class="s2">"abc"</span>
隐式类型定义： const <span class="nv">b</span> <span class="o">=</span> <span class="s2">"abc"</span>

多个类型定义： const c_name1, <span class="nv">c_name2</span> <span class="o">=</span> value1, value2
</code></pre></div>
<ul>
<li>字符串类型</li>
</ul>
<div class="highlight"><pre><span></span><code>    var b <span class="nv">string</span> <span class="o">=</span> <span class="s2">"demo"</span>
    c :<span class="o">=</span>  <span class="s2">"godemo"</span>
</code></pre></div>
<ul>
<li>数组类型</li>
</ul>
<div class="highlight"><pre><span></span><code>//第一种
var arr <span class="o">[</span><span class="m">2</span><span class="o">]</span>int
    arr<span class="o">[</span><span class="m">0</span><span class="o">]=</span><span class="m">1</span>
    arr<span class="o">[</span><span class="m">1</span><span class="o">]=</span><span class="m">2</span>

//第二种

var <span class="nv">arr</span> <span class="o">=</span> <span class="o">[</span><span class="m">2</span><span class="o">]</span>int<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>
arr :<span class="o">=</span> <span class="o">[</span><span class="m">2</span><span class="o">]</span>int<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>

//第三种

var <span class="nv">arr</span> <span class="o">=</span> <span class="o">[</span>...<span class="o">]</span>int<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>
arr :<span class="o">=</span> <span class="o">[</span>...<span class="o">]</span>int<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>

//第四种
<span class="o">{</span>索引1:元素1,索引2:元素2,...<span class="o">}</span>
var <span class="nv">arr</span> <span class="o">=</span> <span class="o">[</span>...<span class="o">]</span>int<span class="o">{</span><span class="m">1</span>:1,0:2<span class="o">}</span>
arr :<span class="o">=</span> <span class="o">[</span>...<span class="o">]</span>int<span class="o">{</span><span class="m">1</span>:1,0:2<span class="o">}</span>
</code></pre></div>
<ul>
<li>切片类型</li>
</ul>
<p>切片就是动态数组</p>
<div class="highlight"><pre><span></span><code>var identifier <span class="o">[]</span><span class="nb">type</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>s :<span class="o">=[]</span> int <span class="o">{</span><span class="m">1</span>,2,3 <span class="o">}</span> 
</code></pre></div>
<p>切片也可以通过make 创建，其中，len 是数组的长度并且也是切片的初始长度，cap 是切片容量</p>
<div class="highlight"><pre><span></span><code>s :<span class="o">=</span>make<span class="o">([]</span>int,len,cap<span class="o">)</span> 
</code></pre></div>
<p>切片使用的例子</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="s2">"fmt"</span>

func main<span class="o">()</span> <span class="o">{</span>
   /* 创建切片 */
   numbers :<span class="o">=</span> <span class="o">[]</span>int<span class="o">{</span><span class="m">0</span>,1,2,3,4,5,6,7,8<span class="o">}</span>   
   printSlice<span class="o">(</span>numbers<span class="o">)</span>

   /* 打印原始切片 */
   fmt.Println<span class="o">(</span><span class="s2">"numbers =="</span>, numbers<span class="o">)</span>

   /* 打印子切片从索引1<span class="o">(</span>包含<span class="o">)</span> 到索引4<span class="o">(</span>不包含<span class="o">)</span>*/
   fmt.Println<span class="o">(</span><span class="s2">"numbers[1:4] =="</span>, numbers<span class="o">[</span><span class="m">1</span>:4<span class="o">])</span>

   /* 默认下限为 <span class="m">0</span>*/
   fmt.Println<span class="o">(</span><span class="s2">"numbers[:3] =="</span>, numbers<span class="o">[</span>:3<span class="o">])</span>

   /* 默认上限为 len<span class="o">(</span>s<span class="o">)</span>*/
   fmt.Println<span class="o">(</span><span class="s2">"numbers[4:] =="</span>, numbers<span class="o">[</span><span class="m">4</span>:<span class="o">])</span>

   numbers1 :<span class="o">=</span> make<span class="o">([]</span>int,0,5<span class="o">)</span>
   printSlice<span class="o">(</span>numbers1<span class="o">)</span>

   /* 打印子切片从索引  <span class="m">0</span><span class="o">(</span>包含<span class="o">)</span> 到索引 <span class="m">2</span><span class="o">(</span>不包含<span class="o">)</span> */
   number2 :<span class="o">=</span> numbers<span class="o">[</span>:2<span class="o">]</span>
   printSlice<span class="o">(</span>number2<span class="o">)</span>

   /* 打印子切片从索引 <span class="m">2</span><span class="o">(</span>包含<span class="o">)</span> 到索引 <span class="m">5</span><span class="o">(</span>不包含<span class="o">)</span> */
   number3 :<span class="o">=</span> numbers<span class="o">[</span><span class="m">2</span>:5<span class="o">]</span>
   printSlice<span class="o">(</span>number3<span class="o">)</span>

<span class="o">}</span>

func printSlice<span class="o">(</span>x <span class="o">[]</span>int<span class="o">){</span>
   fmt.Printf<span class="o">(</span><span class="s2">"len=%d cap=%d slice=%v\n"</span>,len<span class="o">(</span>x<span class="o">)</span>,cap<span class="o">(</span>x<span class="o">)</span>,x<span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>执行以上代码输出结果为：</p>
<div class="highlight"><pre><span></span><code><span class="nv">len</span><span class="o">=</span><span class="m">9</span> <span class="nv">cap</span><span class="o">=</span><span class="m">9</span> <span class="nv">slice</span><span class="o">=[</span><span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span><span class="o">]</span>
<span class="nv">numbers</span> <span class="o">==</span> <span class="o">[</span><span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span><span class="o">]</span>
numbers<span class="o">[</span><span class="m">1</span>:4<span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="m">1</span> <span class="m">2</span> <span class="m">3</span><span class="o">]</span>
numbers<span class="o">[</span>:3<span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="m">0</span> <span class="m">1</span> <span class="m">2</span><span class="o">]</span>
numbers<span class="o">[</span><span class="m">4</span>:<span class="o">]</span> <span class="o">==</span> <span class="o">[</span><span class="m">4</span> <span class="m">5</span> <span class="m">6</span> <span class="m">7</span> <span class="m">8</span><span class="o">]</span>
<span class="nv">len</span><span class="o">=</span><span class="m">0</span> <span class="nv">cap</span><span class="o">=</span><span class="m">5</span> <span class="nv">slice</span><span class="o">=[]</span>
<span class="nv">len</span><span class="o">=</span><span class="m">2</span> <span class="nv">cap</span><span class="o">=</span><span class="m">9</span> <span class="nv">slice</span><span class="o">=[</span><span class="m">0</span> <span class="m">1</span><span class="o">]</span>
<span class="nv">len</span><span class="o">=</span><span class="m">3</span> <span class="nv">cap</span><span class="o">=</span><span class="m">7</span> <span class="nv">slice</span><span class="o">=[</span><span class="m">2</span> <span class="m">3</span> <span class="m">4</span><span class="o">]</span>
</code></pre></div>
<p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。
下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="s2">"fmt"</span>

func main<span class="o">()</span> <span class="o">{</span>
   var numbers <span class="o">[]</span>int
   printSlice<span class="o">(</span>numbers<span class="o">)</span>

   /* 允许追加空切片 */
   <span class="nv">numbers</span> <span class="o">=</span> append<span class="o">(</span>numbers, <span class="m">0</span><span class="o">)</span>
   printSlice<span class="o">(</span>numbers<span class="o">)</span>

   /* 向切片添加一个元素 */
   <span class="nv">numbers</span> <span class="o">=</span> append<span class="o">(</span>numbers, <span class="m">1</span><span class="o">)</span>
   printSlice<span class="o">(</span>numbers<span class="o">)</span>

   /* 同时添加多个元素 */
   <span class="nv">numbers</span> <span class="o">=</span> append<span class="o">(</span>numbers, <span class="m">2</span>,3,4<span class="o">)</span>
   printSlice<span class="o">(</span>numbers<span class="o">)</span>

   /* 创建切片 numbers1 是之前切片的两倍容量*/
   numbers1 :<span class="o">=</span> make<span class="o">([]</span>int, len<span class="o">(</span>numbers<span class="o">)</span>, <span class="o">(</span>cap<span class="o">(</span>numbers<span class="o">))</span>*2<span class="o">)</span>

   /* 拷贝 numbers 的内容到 numbers1 */
   copy<span class="o">(</span>numbers1,numbers<span class="o">)</span>
   printSlice<span class="o">(</span>numbers1<span class="o">)</span>   
<span class="o">}</span>

func printSlice<span class="o">(</span>x <span class="o">[]</span>int<span class="o">){</span>
   fmt.Printf<span class="o">(</span><span class="s2">"len=%d cap=%d slice=%v\n"</span>,len<span class="o">(</span>x<span class="o">)</span>,cap<span class="o">(</span>x<span class="o">)</span>,x<span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<p>以上代码执行输出结果为：</p>
<div class="highlight"><pre><span></span><code><span class="nv">len</span><span class="o">=</span><span class="m">0</span> <span class="nv">cap</span><span class="o">=</span><span class="m">0</span> <span class="nv">slice</span><span class="o">=[]</span>
<span class="nv">len</span><span class="o">=</span><span class="m">1</span> <span class="nv">cap</span><span class="o">=</span><span class="m">1</span> <span class="nv">slice</span><span class="o">=[</span><span class="m">0</span><span class="o">]</span>
<span class="nv">len</span><span class="o">=</span><span class="m">2</span> <span class="nv">cap</span><span class="o">=</span><span class="m">2</span> <span class="nv">slice</span><span class="o">=[</span><span class="m">0</span> <span class="m">1</span><span class="o">]</span>
<span class="nv">len</span><span class="o">=</span><span class="m">5</span> <span class="nv">cap</span><span class="o">=</span><span class="m">6</span> <span class="nv">slice</span><span class="o">=[</span><span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span><span class="o">]</span>
<span class="nv">len</span><span class="o">=</span><span class="m">5</span> <span class="nv">cap</span><span class="o">=</span><span class="m">12</span> <span class="nv">slice</span><span class="o">=[</span><span class="m">0</span> <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span><span class="o">]</span>
</code></pre></div>
<ul>
<li>指针类型（Pointer）</li>
</ul>
<p>指针类型就是一个变量，里面存的是另一个变量的地址</p>
<div class="highlight"><pre><span></span><code>var b *int

<span class="nv">b</span> <span class="o">=</span> <span class="p">&amp;</span>a

var b *int <span class="o">=</span> <span class="p">&amp;</span>a

b :<span class="o">=</span> <span class="p">&amp;</span>a
</code></pre></div>
<div class="highlight"><pre><span></span><code>package main 

import <span class="s2">"fmt"</span>

func main<span class="o">(){</span>

    var a <span class="nv">int</span> <span class="o">=</span> <span class="m">1</span>

    var b *int <span class="o">=</span><span class="p">&amp;</span>a

    fmt.Println<span class="o">(</span>*b<span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<ul>
<li>结构体类型(struct)</li>
</ul>
<p>定义结构体</p>
<div class="highlight"><pre><span></span><code><span class="nb">type</span> struct_variable_type struct <span class="o">{</span>
   member definition<span class="p">;</span>
   member definition<span class="p">;</span>
   ...
   member definition<span class="p">;</span>
<span class="o">}</span>
</code></pre></div>
<p>列子</p>
<div class="highlight"><pre><span></span><code><span class="nb">type</span> Books struct <span class="o">{</span>
   title string
   author string
   subject string
   book_id int
<span class="o">}</span>
</code></pre></div>
<p>如果要访问结构体成员，需要使用点号 . 操作符，格式为：</p>
<p>结构体.成员名</p>
<p>定义指向结构体的指针类似于其他指针变量，格式如下：</p>
<p>var struct_pointer *Books</p>
<p>以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：</p>
<p>struct_pointer = &amp;Book1</p>
<p>使用结构体指针访问结构体成员，使用 "." 操作符：</p>
<p>struct_pointer.title;</p>
<ul>
<li>Channel 类型</li>
</ul>
<div class="highlight"><pre><span></span><code>ch :<span class="o">=</span> chan int // 定义一个chan
ch :<span class="o">=</span> make<span class="o">(</span>chan int<span class="o">)</span>  //定义一个chan
ch &lt;- v    // 把 v 发送到通道 ch
v :<span class="o">=</span> &lt;-ch  // 从 ch 接收数据
           // 并把值赋给 v
</code></pre></div>
<ul>
<li>接口类型（interface）</li>
</ul>
<div class="highlight"><pre><span></span><code>/* 定义接口 */
<span class="nb">type</span> interface_name interface <span class="o">{</span>
   method_name1 <span class="o">[</span>return_type<span class="o">]</span>
   method_name2 <span class="o">[</span>return_type<span class="o">]</span>
   method_name3 <span class="o">[</span>return_type<span class="o">]</span>
   ...
   method_namen <span class="o">[</span>return_type<span class="o">]</span>
<span class="o">}</span>

/* 定义结构体 */
<span class="nb">type</span> struct_name struct <span class="o">{</span>
   /* variables */
<span class="o">}</span>

/* 实现接口方法 */
func <span class="o">(</span>struct_name_variable struct_name<span class="o">)</span> method_name1<span class="o">()</span> <span class="o">[</span>return_type<span class="o">]</span> <span class="o">{</span>
   /* 方法实现 */
<span class="o">}</span>
...
func <span class="o">(</span>struct_name_variable struct_name<span class="o">)</span> method_namen<span class="o">()</span> <span class="o">[</span>return_type<span class="o">]</span> <span class="o">{</span>
   /* 方法实现*/
<span class="o">}</span>
</code></pre></div>
<ul>
<li>Map 类型</li>
</ul>
<div class="highlight"><pre><span></span><code>/* 声明变量，默认 map 是 nil */
var map_variable map<span class="o">[</span>key_data_type<span class="o">]</span>value_data_type

/* 使用 make 函数 */
map_variable :<span class="o">=</span> make<span class="o">(</span>map<span class="o">[</span>key_data_type<span class="o">]</span>value_data_type<span class="o">)</span>

/ * map 初始化 * /
var <span class="nv">map_variable</span> <span class="o">=</span> map<span class="o">[</span>string<span class="o">]</span>string<span class="o">{</span><span class="s2">"key1"</span>: <span class="s2">"value1"</span>,<span class="s2">"key2"</span>: <span class="s2">"value2"</span>,<span class="o">}</span>
</code></pre></div>
<ul>
<li>类型转换</li>
</ul>
<div class="highlight"><pre><span></span><code>Go 语言类型转换基本格式如下：
    type_name<span class="o">(</span>expression<span class="o">)</span>
    type_name 为类型，expression 为表达式。
</code></pre></div>
<ul>
<li>range</li>
</ul>
<p>range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在map 中返回 key 和 value。</p>
<div class="highlight"><pre><span></span><code>package main
import <span class="s2">"fmt"</span>
func main<span class="o">()</span> <span class="o">{</span>
    //这是我们使用range去求一个slice的和。使用数组跟这个很类似
    nums :<span class="o">=</span> <span class="o">[]</span>int<span class="o">{</span><span class="m">2</span>, <span class="m">3</span>, <span class="m">4</span><span class="o">}</span>
    sum :<span class="o">=</span> <span class="m">0</span>
    <span class="k">for</span> _, num :<span class="o">=</span> range nums <span class="o">{</span>
        <span class="nv">sum</span> <span class="o">+=</span> num
    <span class="o">}</span>
    fmt.Println<span class="o">(</span><span class="s2">"sum:"</span>, sum<span class="o">)</span>
    //在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符<span class="s2">"_"</span>省略了。有时侯我们确实需要知道它的索引。
    <span class="k">for</span> i, num :<span class="o">=</span> range nums <span class="o">{</span>
        <span class="k">if</span> <span class="nv">num</span> <span class="o">==</span> <span class="m">3</span> <span class="o">{</span>
            fmt.Println<span class="o">(</span><span class="s2">"index:"</span>, i<span class="o">)</span>
        <span class="o">}</span>
    <span class="o">}</span>
    //range也可以用在map的键值对上。
    kvs :<span class="o">=</span> map<span class="o">[</span>string<span class="o">]</span>string<span class="o">{</span><span class="s2">"a"</span>: <span class="s2">"apple"</span>, <span class="s2">"b"</span>: <span class="s2">"banana"</span><span class="o">}</span>
    <span class="k">for</span> k, v :<span class="o">=</span> range kvs <span class="o">{</span>
        fmt.Printf<span class="o">(</span><span class="s2">"%s -&gt; %s\n"</span>, k, v<span class="o">)</span>
    <span class="o">}</span>
    //range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。
    <span class="k">for</span> i, c :<span class="o">=</span> range <span class="s2">"go"</span> <span class="o">{</span>
        fmt.Println<span class="o">(</span>i, c<span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h4>运算符</h4>
<p>算术运算符</p>
<div class="highlight"><pre><span></span><code>+   相加  
-   相减  
*   相乘  
/   相除  
%   求余  
++  自增  
--  自减  
</code></pre></div>
<p>关系运算符</p>
<div class="highlight"><pre><span></span><code><span class="o">==</span>  检查两个值是否相等，如果相等返回 True 否则返回 False。
!<span class="o">=</span>  检查两个值是否不相等，如果不相等返回 True 否则返回 False。
&gt;   检查左边值是否大于右边值，如果是返回 True 否则返回 False。
&gt;<span class="o">=</span>  检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。
&lt;<span class="o">=</span>  检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。
</code></pre></div>
<p>逻辑运算符</p>
<div class="highlight"><pre><span></span><code><span class="o">&amp;&amp;</span>  逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。
<span class="o">||</span>  逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。
!   逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。
</code></pre></div>
<p>赋值运算符</p>
<div class="highlight"><pre><span></span><code><span class="o">=</span>   简单的赋值运算符，将一个表达式的值赋给一个左值
+<span class="o">=</span>  相加后再赋值  <span class="nv">C</span> <span class="o">+=</span> A 等于 <span class="nv">C</span> <span class="o">=</span> C + A
-<span class="o">=</span>  相减后再赋值  C -<span class="o">=</span> A 等于 <span class="nv">C</span> <span class="o">=</span> C - A
*<span class="o">=</span>  相乘后再赋值  C *<span class="o">=</span> A 等于 <span class="nv">C</span> <span class="o">=</span> C * A
/<span class="o">=</span>  相除后再赋值  C /<span class="o">=</span> A 等于 <span class="nv">C</span> <span class="o">=</span> C / A
%<span class="o">=</span>  求余后再赋值   C %<span class="o">=</span> A 等于 <span class="nv">C</span> <span class="o">=</span> C % A
</code></pre></div>
<p>指针相关运算符</p>
<div class="highlight"><pre><span></span><code><span class="p">&amp;</span>   返回变量存储地址    <span class="p">&amp;</span>a<span class="p">;</span> 将给出变量的实际地址。
*   指针变量。   *a<span class="p">;</span> 是一个指针变量
</code></pre></div>
<h4>控制语句</h4>
<ul>
<li>条件语句</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">if</span> 布尔表达式 <span class="o">{</span>
   /* 在布尔表达式为 <span class="nb">true</span> 时执行 */
<span class="o">}</span>

<span class="k">if</span> 布尔表达式 <span class="o">{</span>
   /* 在布尔表达式为 <span class="nb">true</span> 时执行 */
<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
  /* 在布尔表达式为 <span class="nb">false</span> 时执行 */
<span class="o">}</span>

<span class="k">if</span> 布尔表达式 <span class="m">1</span> <span class="o">{</span>
   /* 在布尔表达式 <span class="m">1</span> 为 <span class="nb">true</span> 时执行 */
   <span class="k">if</span> 布尔表达式 <span class="m">2</span> <span class="o">{</span>
      /* 在布尔表达式 <span class="m">2</span> 为 <span class="nb">true</span> 时执行 */
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>for 循环</p>
<div class="highlight"><pre><span></span><code>Go语言的For循环有3中形式，只有其中的一种使用分号。

和 C 语言的 <span class="k">for</span> 一样：

<span class="k">for</span> init<span class="p">;</span> condition<span class="p">;</span> post <span class="o">{</span> <span class="o">}</span>
和 C 的 <span class="k">while</span> 一样：

<span class="k">for</span> condition <span class="o">{</span> <span class="o">}</span>
和 C 的 <span class="k">for</span><span class="o">(</span><span class="p">;;</span><span class="o">)</span> 一样：

<span class="k">for</span> <span class="o">{</span> <span class="o">}</span>
init： 一般为赋值表达式，给控制变量赋初值；
condition： 关系表达式或逻辑表达式，循环控制条件；
post： 一般为赋值表达式，给控制变量增量或减量。
</code></pre></div>
<p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> key, value :<span class="o">=</span> range oldMap <span class="o">{</span>
    newMap<span class="o">[</span>key<span class="o">]</span> <span class="o">=</span> value
<span class="o">}</span>
</code></pre></div>
<p>for 例子</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="s2">"fmt"</span>

func main<span class="o">()</span> <span class="o">{</span>

   var b <span class="nv">int</span> <span class="o">=</span> <span class="m">15</span>
   var a int

   numbers :<span class="o">=</span> <span class="o">[</span><span class="m">6</span><span class="o">]</span>int<span class="o">{</span><span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>, <span class="m">5</span><span class="o">}</span> 

   /* <span class="k">for</span> 循环 */
   <span class="k">for</span> a :<span class="o">=</span> <span class="m">0</span><span class="p">;</span> a &lt; <span class="m">10</span><span class="p">;</span> a++ <span class="o">{</span>
      fmt.Printf<span class="o">(</span><span class="s2">"a 的值为: %d\n"</span>, a<span class="o">)</span>
   <span class="o">}</span>

   <span class="k">for</span> a &lt; b <span class="o">{</span>
      a++
      fmt.Printf<span class="o">(</span><span class="s2">"a 的值为: %d\n"</span>, a<span class="o">)</span>
   <span class="o">}</span>

   <span class="k">for</span> i,x:<span class="o">=</span> range numbers <span class="o">{</span>
      fmt.Printf<span class="o">(</span><span class="s2">"第 %d 位 x 的值 = %d\n"</span>, i,x<span class="o">)</span>
   <span class="o">}</span>   
<span class="o">}</span>
</code></pre></div>
<p>for 无限循环</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="s2">"fmt"</span>

func main<span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="nb">true</span>  <span class="o">{</span>
        fmt.Printf<span class="o">(</span><span class="s2">"这是无限循环。\n"</span><span class="o">)</span><span class="p">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>break 语句</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="s2">"fmt"</span>

func main<span class="o">()</span> <span class="o">{</span>
   /* 定义局部变量 */
   var a <span class="nv">int</span> <span class="o">=</span> <span class="m">10</span>

   /* <span class="k">for</span> 循环 */
   <span class="k">for</span> a &lt; <span class="m">20</span> <span class="o">{</span>
      fmt.Printf<span class="o">(</span><span class="s2">"a 的值为 : %d\n"</span>, a<span class="o">)</span><span class="p">;</span>
      a++<span class="p">;</span>
      <span class="k">if</span> a &gt; <span class="m">15</span> <span class="o">{</span>
         /* 使用 <span class="nb">break</span> 语句跳出循环 */
         break<span class="p">;</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>continue 语句</p>
<div class="highlight"><pre><span></span><code>import <span class="s2">"fmt"</span>

func main<span class="o">()</span> <span class="o">{</span>
   /* 定义局部变量 */
   var a <span class="nv">int</span> <span class="o">=</span> <span class="m">10</span>

   /* <span class="k">for</span> 循环 */
   <span class="k">for</span> a &lt; <span class="m">20</span> <span class="o">{</span>
      <span class="k">if</span> <span class="nv">a</span> <span class="o">==</span> <span class="m">15</span> <span class="o">{</span>
         /* 跳过此次循环 */
         <span class="nv">a</span> <span class="o">=</span> a + <span class="m">1</span><span class="p">;</span>
         <span class="k">continue</span><span class="p">;</span>
      <span class="o">}</span>
      fmt.Printf<span class="o">(</span><span class="s2">"a 的值为 : %d\n"</span>, a<span class="o">)</span><span class="p">;</span>
      a++<span class="p">;</span>     
   <span class="o">}</span>  
<span class="o">}</span>
</code></pre></div>
<h4>函数</h4>
<p>函数定义 </p>
<div class="highlight"><pre><span></span><code>func function_name<span class="o">(</span> <span class="o">[</span>parameter list<span class="o">]</span> <span class="o">)</span> <span class="o">[</span>return_types<span class="o">]</span> <span class="o">{</span>
   函数体
<span class="o">}</span>
</code></pre></div>
<p>以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：</p>
<div class="highlight"><pre><span></span><code>/* 函数返回两个数的最大值 */
func max<span class="o">(</span>num1, num2 int<span class="o">)</span> int <span class="o">{</span>
   /* 声明局部变量 */
   var result int

   <span class="k">if</span> <span class="o">(</span>num1 &gt; num2<span class="o">)</span> <span class="o">{</span>
      <span class="nv">result</span> <span class="o">=</span> num1
   <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="nv">result</span> <span class="o">=</span> num2
   <span class="o">}</span>
   <span class="k">return</span> result 
<span class="o">}</span>
</code></pre></div>
<p>向函数传递数组</p>
<div class="highlight"><pre><span></span><code>形参设定数组大小：

void myFunction<span class="o">(</span>param <span class="o">[</span><span class="m">10</span><span class="o">]</span>int<span class="o">)</span>
<span class="o">{</span>
<span class="o">}</span>

形参未设定数组大小：

void myFunction<span class="o">(</span>param <span class="o">[]</span>int<span class="o">)</span>
<span class="o">{</span>
<span class="o">}</span>
</code></pre></div>
<p>列子</p>
<div class="highlight"><pre><span></span><code>func main<span class="o">()</span> <span class="o">{</span>
    var <span class="nv">array</span> <span class="o">=</span> <span class="o">[]</span>int<span class="o">{</span><span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>, <span class="m">4</span>, <span class="m">5</span><span class="o">}</span>
    /* 未定义长度的数组只能传给不限制数组长度的函数 */
    setArray<span class="o">(</span>array<span class="o">)</span>
    /* 定义了长度的数组只能传给限制了相同数组长度的函数 */
    var <span class="nv">array2</span> <span class="o">=</span> <span class="o">[</span><span class="m">5</span><span class="o">]</span>int<span class="o">{</span><span class="m">1</span>, <span class="m">2</span>, <span class="m">3</span>, <span class="m">4</span>, <span class="m">5</span><span class="o">}</span>
    setArray2<span class="o">(</span>array2<span class="o">)</span>
<span class="o">}</span>

func setArray<span class="o">(</span>params <span class="o">[]</span>int<span class="o">)</span> <span class="o">{</span>
    fmt.Println<span class="o">(</span><span class="s2">"params array length of setArray is : "</span>, len<span class="o">(</span>params<span class="o">))</span>
<span class="o">}</span>

func setArray2<span class="o">(</span>params <span class="o">[</span><span class="m">5</span><span class="o">]</span>int<span class="o">)</span> <span class="o">{</span>
    fmt.Println<span class="o">(</span><span class="s2">"params array length of setArray2 is : "</span>, len<span class="o">(</span>params<span class="o">))</span>
<span class="o">}</span>
</code></pre></div>
<p>函数可以作为值</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="o">(</span>
   <span class="s2">"fmt"</span>
   <span class="s2">"math"</span>
<span class="o">)</span>

func main<span class="o">(){</span>
   /* 声明函数变量 */
   getSquareRoot :<span class="o">=</span> func<span class="o">(</span>x float64<span class="o">)</span> float64 <span class="o">{</span>
      <span class="k">return</span> math.Sqrt<span class="o">(</span>x<span class="o">)</span>
   <span class="o">}</span>

   /* 使用函数 */
   fmt.Println<span class="o">(</span>getSquareRoot<span class="o">(</span><span class="m">9</span><span class="o">))</span>

<span class="o">}</span>
</code></pre></div>
<p>闭包</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="s2">"fmt"</span>

func getSequence<span class="o">()</span> func<span class="o">()</span> int <span class="o">{</span>
   i:<span class="o">=</span><span class="m">0</span>
   <span class="k">return</span> func<span class="o">()</span> int <span class="o">{</span>
      <span class="nv">i</span><span class="o">+=</span><span class="m">1</span>
     <span class="k">return</span> i  
   <span class="o">}</span>
<span class="o">}</span>

func main<span class="o">(){</span>
   /* nextNumber 为一个函数，函数 i 为 <span class="m">0</span> */
   nextNumber :<span class="o">=</span> getSequence<span class="o">()</span>  

   /* 调用 nextNumber 函数，i 变量自增 <span class="m">1</span> 并返回 */
   fmt.Println<span class="o">(</span>nextNumber<span class="o">())</span>
   fmt.Println<span class="o">(</span>nextNumber<span class="o">())</span>
   fmt.Println<span class="o">(</span>nextNumber<span class="o">())</span>

   /* 创建新的函数 nextNumber1，并查看结果 */
   nextNumber1 :<span class="o">=</span> getSequence<span class="o">()</span>  
   fmt.Println<span class="o">(</span>nextNumber1<span class="o">())</span>
   fmt.Println<span class="o">(</span>nextNumber1<span class="o">())</span>
<span class="o">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>package main

import <span class="s2">"fmt"</span>
func main<span class="o">()</span> <span class="o">{</span>
    add_func :<span class="o">=</span> add<span class="o">(</span><span class="m">1</span>,2<span class="o">)</span>
    fmt.Println<span class="o">(</span>add_func<span class="o">())</span>
    fmt.Println<span class="o">(</span>add_func<span class="o">())</span>
    fmt.Println<span class="o">(</span>add_func<span class="o">())</span>
<span class="o">}</span>

// 闭包使用方法
func add<span class="o">(</span>x1, x2 int<span class="o">)</span> func<span class="o">()(</span>int,int<span class="o">)</span>  <span class="o">{</span>
    i :<span class="o">=</span> <span class="m">0</span>
    <span class="k">return</span> func<span class="o">()</span> <span class="o">(</span>int,int<span class="o">){</span>
        i++
        <span class="k">return</span> i,x1+x2
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>package main
import <span class="s2">"fmt"</span>
func main<span class="o">()</span> <span class="o">{</span>
    add_func :<span class="o">=</span> add<span class="o">(</span><span class="m">1</span>,2<span class="o">)</span>
    fmt.Println<span class="o">(</span>add_func<span class="o">(</span><span class="m">1</span>,1<span class="o">))</span>
    fmt.Println<span class="o">(</span>add_func<span class="o">(</span><span class="m">0</span>,0<span class="o">))</span>
    fmt.Println<span class="o">(</span>add_func<span class="o">(</span><span class="m">2</span>,2<span class="o">))</span>
<span class="o">}</span> 
// 闭包使用方法
func add<span class="o">(</span>x1, x2 int<span class="o">)</span> func<span class="o">(</span>x3 int,x4 int<span class="o">)(</span>int,int,int<span class="o">)</span>  <span class="o">{</span>
    i :<span class="o">=</span> <span class="m">0</span>
    <span class="k">return</span> func<span class="o">(</span>x3 int,x4 int<span class="o">)</span> <span class="o">(</span>int,int,int<span class="o">){</span> 
       i++
       <span class="k">return</span> i,x1+x2,x3+x4
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<h4>接口</h4>
<div class="highlight"><pre><span></span><code>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。

实例
/* 定义接口 */
<span class="nb">type</span> interface_name interface <span class="o">{</span>
   method_name1 <span class="o">[</span>return_type<span class="o">]</span>
   method_name2 <span class="o">[</span>return_type<span class="o">]</span>
   method_name3 <span class="o">[</span>return_type<span class="o">]</span>
   ...
   method_namen <span class="o">[</span>return_type<span class="o">]</span>
<span class="o">}</span>

/* 定义结构体 */
<span class="nb">type</span> struct_name struct <span class="o">{</span>
   /* variables */
<span class="o">}</span>

/* 实现接口方法 */
func <span class="o">(</span>struct_name_variable struct_name<span class="o">)</span> method_name1<span class="o">()</span> <span class="o">[</span>return_type<span class="o">]</span> <span class="o">{</span>
   /* 方法实现 */
<span class="o">}</span>
...
func <span class="o">(</span>struct_name_variable struct_name<span class="o">)</span> method_namen<span class="o">()</span> <span class="o">[</span>return_type<span class="o">]</span> <span class="o">{</span>
   /* 方法实现*/
<span class="o">}</span>
</code></pre></div>
<p>例子</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="o">(</span>
    <span class="s2">"fmt"</span>
<span class="o">)</span>

<span class="nb">type</span> Phone interface <span class="o">{</span>
    call<span class="o">()</span>
<span class="o">}</span>

<span class="nb">type</span> NokiaPhone struct <span class="o">{</span>
<span class="o">}</span>

func <span class="o">(</span>nokiaPhone NokiaPhone<span class="o">)</span> call<span class="o">()</span> <span class="o">{</span>
    fmt.Println<span class="o">(</span><span class="s2">"I am Nokia, I can call you!"</span><span class="o">)</span>
<span class="o">}</span>

<span class="nb">type</span> IPhone struct <span class="o">{</span>
<span class="o">}</span>

func <span class="o">(</span>iPhone IPhone<span class="o">)</span> call<span class="o">()</span> <span class="o">{</span>
    fmt.Println<span class="o">(</span><span class="s2">"I am iPhone, I can call you!"</span><span class="o">)</span>
<span class="o">}</span>

func main<span class="o">()</span> <span class="o">{</span>
    var phone Phone

    <span class="nv">phone</span> <span class="o">=</span> new<span class="o">(</span>NokiaPhone<span class="o">)</span>
    phone.call<span class="o">()</span>

    <span class="nv">phone</span> <span class="o">=</span> new<span class="o">(</span>IPhone<span class="o">)</span>
    phone.call<span class="o">()</span>

<span class="o">}</span>
</code></pre></div>
<h4>面向对象</h4>
<p>面向对象的方法</p>
<div class="highlight"><pre><span></span><code>package main

import <span class="o">(</span>
   <span class="s2">"fmt"</span>  
<span class="o">)</span>

/* 定义结构体 */
<span class="nb">type</span> Circle struct <span class="o">{</span>
  radius float64
<span class="o">}</span>

func main<span class="o">()</span> <span class="o">{</span>
  var c1 Circle
  c1.radius <span class="o">=</span> <span class="m">10</span>.00
  fmt.Println<span class="o">(</span><span class="s2">"圆的面积 = "</span>, c1.getArea<span class="o">())</span>
<span class="o">}</span>

//该 method 属于 Circle 类型对象中的方法
func <span class="o">(</span>c Circle<span class="o">)</span> getArea<span class="o">()</span> float64 <span class="o">{</span>
  //c.radius 即为 Circle 类型对象中的属性
  <span class="k">return</span> <span class="m">3</span>.14 * c.radius * c.radius
<span class="o">}</span>
</code></pre></div>
<h4>GO IO</h4>
<h4>GO异常处理</h4>
<p>这里会提到3个关键词， defer, panic, recover
defer就是用来添加函数结束时执行的语句，Go中的defer是动态的。</p>
<div class="highlight"><pre><span></span><code>func f<span class="o">()</span> <span class="o">(</span>result int<span class="o">)</span> <span class="o">{</span>

  deferfunc<span class="o">()</span> <span class="o">{</span>
    result++
  <span class="o">}()</span>
  return0
<span class="o">}</span>
</code></pre></div>
<p>上面函数返回1，因为defer中添加了一个函数，在函数返回前改变了命名返回值的值。是不是很好用呢。但是，要注意的是，如果我们的defer语句没有执行，那么defer的函数就不会添加，如果把上面的程序改成这样：</p>
<div class="highlight"><pre><span></span><code>    func f<span class="o">()</span> <span class="o">(</span>result int<span class="o">)</span> <span class="o">{</span>

      return0
      deferfunc<span class="o">()</span> <span class="o">{</span>
        result++
      <span class="o">}()</span>
      return0
    <span class="o">}</span>
</code></pre></div>
<p>然后，我们在defer里面用recover捕获panic，完成go的异常处理</p>
<div class="highlight"><pre><span></span><code>package main
import <span class="s2">"fmt"</span>
func main<span class="o">(){</span>
    defer func<span class="o">(){</span> // 必须要先声明defer，否则不能捕获到panic异常
        fmt.Println<span class="o">(</span><span class="s2">"c"</span><span class="o">)</span>
        <span class="k">if</span> err:<span class="o">=</span>recover<span class="o">()</span><span class="p">;</span>err!<span class="o">=</span>nil<span class="o">{</span>
            fmt.Println<span class="o">(</span>err<span class="o">)</span> // 这里的err其实就是panic传入的内容，55
        <span class="o">}</span>
        fmt.Println<span class="o">(</span><span class="s2">"d"</span><span class="o">)</span>
    <span class="o">}()</span>
    f<span class="o">()</span>
<span class="o">}</span>
func f<span class="o">(){</span>
    fmt.Println<span class="o">(</span><span class="s2">"a"</span><span class="o">)</span>
    panic<span class="o">(</span><span class="m">55</span><span class="o">)</span>
    fmt.Println<span class="o">(</span><span class="s2">"b"</span><span class="o">)</span>
    fmt.Println<span class="o">(</span><span class="s2">"f"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<h4>GO 并发</h4>
<h4>标准库</h4>
<div class="highlight"><pre><span></span><code>archive         
     tar            tar包实现了tar格式压缩文件的存取.
     zip            zip包提供了zip档案文件的读写服务.
bufio           bufio 包实现了带缓存的I/O操作.
<span class="nb">builtin</span>         <span class="nb">builtin</span> 包为Go的预声明标识符提供了文档.
bytes           bytes包实现了操作<span class="o">[]</span>byte的常用函数.
compress            
     bzip2          bzip2包实现bzip2的解压缩.
     flate          flate包实现了deflate压缩数据格式，参见RFC <span class="m">1951</span>.
     gzip           gzip包实现了gzip格式压缩文件的读写，参见RFC <span class="m">1952</span>.
     lzw            lzw包实现了Lempel-Ziv-Welch数据压缩格式，这是一种T. A. Welch在“A Technique <span class="k">for</span> High-Performance Data Compression”一文（Computer, <span class="m">17</span><span class="o">(</span><span class="m">6</span><span class="o">)</span> <span class="o">(</span>June <span class="m">1984</span><span class="o">)</span>, pp <span class="m">8</span>-19）提出的一种压缩格式.
     zlib           zlib包实现了对zlib格式压缩数据的读写，参见RFC <span class="m">1950</span>.
container           
     heap           heap包提供了对任意类型（实现了heap.Interface接口）的堆操作.
     list           list包实现了双向链表.
     ring           ring实现了环形链表的操作.
context         Package context defines the Context type, which carries deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes.
crypto          crypto包搜集了常用的密码（算法）常量.
     aes            aes包实现了AES加密算法，参见U.S. Federal Information Processing Standards Publication <span class="m">197</span>.
     cipher         cipher包实现了多个标准的用于包装底层块加密算法的加密算法实现.
     des            des包实现了DES标准和TDEA算法，参见U.S. Federal Information Processing Standards Publication <span class="m">46</span>-3.
     dsa            dsa包实现FIPS <span class="m">186</span>-3定义的数字签名算法（Digital Signature Algorithm），即DSA算法.
     ecdsa          ecdsa包实现了椭圆曲线数字签名算法，参见FIPS <span class="m">186</span>-3.
     elliptic           elliptic包实现了几条覆盖素数有限域的标准椭圆曲线.
     hmac           hmac包实现了U.S. Federal Information Processing Standards Publication 198规定的HMAC（加密哈希信息认证码）.
     md5            md5包实现了MD5哈希算法，参见RFC <span class="m">1321</span>.
     rand           rand包实现了用于加解密的更安全的随机数生成器.
     rc4            rc4包实现了RC4加密算法，参见Bruce Schneier<span class="err">'</span>s Applied Cryptography.
     rsa            rsa包实现了PKCS#1规定的RSA加密算法.
     sha1           sha1包实现了SHA1哈希算法，参见RFC <span class="m">3174</span>.
     sha256         sha256包实现了SHA224和SHA256哈希算法，参见FIPS <span class="m">180</span>-4.
     sha512         sha512包实现了SHA384和SHA512哈希算法，参见FIPS <span class="m">180</span>-2.
     subtle         Package subtle implements functions that are often useful <span class="k">in</span> cryptographic code but require careful thought to use correctly.
     tls            tls包实现了TLS <span class="m">1</span>.2，细节参见RFC <span class="m">5246</span>.
     x509           x509包解析X.509编码的证书和密钥.
          pkix          pkix包提供了共享的、低层次的结构体，用于ASN.1解析和X.509证书、CRL、OCSP的序列化.
database            
     sql            sql 包提供了通用的SQL（或类SQL）数据库接口.
          driver            driver包定义了应被数据库驱动实现的接口，这些接口会被sql包使用.
debug           
     dwarf          Package dwarf provides access to DWARF debugging information loaded from executable files, as defined <span class="k">in</span> the DWARF <span class="m">2</span>.0 Standard at http://dwarfstd.org/doc/dwarf-2.0.0.pdf
     elf            Package elf implements access to ELF object files.
     gosym          Package gosym implements access to the Go symbol and line number tables embedded <span class="k">in</span> Go binaries generated by the gc compilers.
     macho          Package macho implements access to Mach-O object files.
     pe         Package pe implements access to PE <span class="o">(</span>Microsoft Windows Portable Executable<span class="o">)</span> files.
     plan9obj           Package plan9obj implements access to Plan <span class="m">9</span> a.out object files.
encoding            encoding包定义了供其它包使用的可以将数据在字节水平和文本表示之间转换的接口.
     ascii85            ascii85 包是对 ascii85 的数据编码的实现.
     asn1           asn1包实现了DER编码的ASN.1数据结构的解析，参见ITU-T Rec X.690.
     base32         base32包实现了RFC 4648规定的base32编码.
     base64         base64实现了RFC 4648规定的base64编码.
     binary         binary包实现了简单的数字与字节序列的转换以及变长值的编解码.
     csv            csv读写逗号分隔值（csv）的文件.
     gob            gob包管理gob流——在编码器（发送器）和解码器（接受器）之间交换的binary值.
     hex            hex包实现了16进制字符表示的编解码.
     json           json包实现了json对象的编解码，参见RFC <span class="m">4627</span>.
     pem            pem包实现了PEM数据编码（源自保密增强邮件协议）.
     xml            Package xml implements a simple XML <span class="m">1</span>.0 parser that understands XML name spaces.
errors          error 包实现了用于错误处理的函数.
expvar          expvar包提供了公共变量的标准接口，如服务的操作计数器.
flag            flag 包实现命令行标签解析.
fmt         fmt 包实现了格式化I/O函数，类似于C的 <span class="nb">printf</span> 和 scanf.
go          
     ast            Package ast declares the types used to represent syntax trees <span class="k">for</span> Go packages.
     build          Package build gathers information about Go packages.
     constant           Package constant implements Values representing untyped Go constants and their corresponding operations.
     doc            Package doc extracts <span class="nb">source</span> code documentation from a Go AST.
     format         Package format implements standard formatting of Go source.
     importer           Package importer provides access to <span class="nb">export</span> data importers.
     parser         Package parser implements a parser <span class="k">for</span> Go <span class="nb">source</span> files.
     printer            Package printer implements printing of AST nodes.
     scanner            Package scanner implements a scanner <span class="k">for</span> Go <span class="nb">source</span> text.
     token          Package token defines constants representing the lexical tokens of the Go programming language and basic operations on tokens <span class="o">(</span>printing, predicates<span class="o">)</span>.
     types          Package types declares the data types and implements the algorithms <span class="k">for</span> type-checking of Go packages.
<span class="nb">hash</span>            hash包提供hash函数的接口.
     adler32            adler32包实现了Adler-32校验和算法，参见RFC <span class="m">1950</span>.
     crc32          crc32包实现了32位循环冗余校验（CRC-32）的校验和算法.
     crc64          Package crc64 implements the <span class="m">64</span>-bit cyclic redundancy check, or CRC-64, checksum.
     fnv            fnv包实现了FNV-1和FNV-1a（非加密hash函数）.
html            html包提供了用于转义和解转义HTML文本的函数.
     template           template包（html/template）实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出.
image           image实现了基本的2D图片库.
     color          color 包实现了基本的颜色库。
          palette           palette包提供了标准的调色板.
     draw           draw 包提供组装图片的方法.
     gif            gif 包实现了GIF图片的解码.
     jpeg           jpeg包实现了jpeg格式图像的编解码.
     png            png 包实现了PNG图像的编码和解码.
index           
     suffixarray            suffixarrayb包通过使用内存中的后缀树实现了对数级时间消耗的子字符串搜索.
io          io 包为I/O原语提供了基础的接口.
     ioutil         ioutil 实现了一些I/O的工具函数。
log         log包实现了简单的日志服务.
     syslog         syslog包提供一个简单的系统日志服务的接口.
math            math 包提供了基本常数和数学函数。
     big            big 包实现了（大数的）高精度运算.
     cmplx          cmplx 包为复数提供了基本的常量和数学函数.
     rand           rand 包实现了伪随机数生成器.
mime            mime实现了MIME的部分规定.
     multipart          multipart实现了MIME的multipart解析，参见RFC <span class="m">2046</span>.
     quotedprintable            Package quotedprintable implements quoted-printable encoding as specified by RFC <span class="m">2045</span>.
net         net包提供了可移植的网络I/O接口，包括TCP/IP、UDP、域名解析和Unix域socket.
     http           http包提供了HTTP客户端和服务端的实现.
          cgi           cgi 包实现了RFC3875协议描述的CGI（公共网关接口）.
          cookiejar         cookiejar包实现了保管在内存中的符合RFC 6265标准的http.CookieJar接口.
          fcgi          fcgi 包实现了FastCGI协议.
          httptest          httptest 包提供HTTP测试的单元工具.
          httptrace         Package httptrace provides mechanisms to trace the events within HTTP client requests.
          httputil          httputil包提供了HTTP公用函数，是对net/http包的更常见函数的补充.
          pprof         pprof 包通过提供HTTP服务返回runtime的统计数据，这个数据是以pprof可视化工具规定的返回格式返回的.
     mail           mail 包实现了解析邮件消息的功能.
     rpc            rpc 包提供了一个方法来通过网络或者其他的I/O连接进入对象的外部方法.
          jsonrpc           jsonrpc 包使用了rpc的包实现了一个JSON-RPC的客户端解码器和服务端的解码器.
     smtp           smtp包实现了简单邮件传输协议（SMTP），参见RFC <span class="m">5321</span>.
     textproto          textproto实现了对基于文本的请求/回复协议的一般性支持，包括HTTP、NNTP和SMTP.
     url            url包解析URL并实现了查询的逸码，参见RFC <span class="m">3986</span>.
os          os包提供了操作系统函数的不依赖平台的接口.
     <span class="nb">exec</span>           exec包执行外部命令.
     signal         signal包实现了对输入信号的访问.
     user           user包允许通过名称或ID查询用户帐户.
path            path实现了对斜杠分隔的路径的实用操作函数.
     filepath           filepath包实现了兼容各操作系统的文件路径的实用操作函数.
plugin          Package plugin implements loading and symbol resolution of Go plugins.
reflect         reflect包实现了运行时反射，允许程序操作任意类型的对象.
regexp          regexp包实现了正则表达式搜索.
     syntax         Package syntax parses regular expressions into parse trees and compiles parse trees into programs.
runtime         TODO<span class="o">(</span>osc<span class="o">)</span>: 需更新 runtime 包含与Go的运行时系统进行交互的操作，例如用于控制Go程的函数.
     cgo            cgo 包含有 cgo 工具生成的代码的运行时支持.
     debug          debug 包含有程序在运行时调试其自身的功能.
     pprof          pprof 包按照可视化工具 pprof 所要求的格式写出运行时分析数据.
     race           race 包实现了数据竞争检测逻辑.
     trace          Go execution tracer.
sort            sort 包为切片及用户定义的集合的排序操作提供了原语.
strconv         strconv包实现了基本数据类型和其字符串表示的相互转换.
strings         strings包实现了用于操作字符的简单函数.
sync            sync 包提供了互斥锁这类的基本的同步原语.
     atomic         atomic 包提供了底层的原子性内存原语，这对于同步算法的实现很有用.
syscall         Package syscall contains an interface to the low-level operating system primitives.
testing         Package testing provides support <span class="k">for</span> automated testing of Go packages.
     iotest         Package iotest implements Readers and Writers useful mainly <span class="k">for</span> testing.
     quick          Package quick implements utility functions to <span class="nb">help</span> with black box testing.
text            
     scanner            scanner包提供对utf-8文本的token扫描服务.
     tabwriter          tabwriter包实现了写入过滤器（tabwriter.Writer），可以将输入的缩进修正为正确的对齐文本.
     template           template包实现了数据驱动的用于生成文本输出的模板.
          parse         Package parse builds parse trees <span class="k">for</span> templates as defined by text/template and html/template.
<span class="nb">time</span>            time包提供了时间的显示和测量用的函数.
unicode         unicode 包提供了一些测试Unicode码点属性的数据和函数.
     utf16          utf16 包实现了对UTF-16序列的编码和解码。
     utf8           utf8 包实现了支持UTF-8文本编码的函数和常量.
unsafe
</code></pre></div>
  </div>
</article>
<div id="cyReward" role="cylabs" data-use="reward" style="text-align:center;"></div>
<!--PC和WAP自适应版-->
<div id="SOHUCS" ></div> 
<script type="text/javascript"> 
(function(){ 
var appid = 'cysYUIjwy'; 
var conf = 'prod_71b5e53cad0d27b5ed44fa5219b069b5'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })(); </script>

<script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cysYUIjwy"></script>    </div>
  </div>

  <footer class="footer">
    <div class="container">
      <div class="row">
       <ul class="col-sm-6 list-inline">
          <li class="list-inline-item"><a href="https://www.njcx.bid/authors.html">Authors</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/archives.html">Archives</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/categories.html">Categories</a></li>
          <li class="list-inline-item"><a href="https://www.njcx.bid/tags.html">Tags</a></li>
        </ul>
        <p class="col-sm-6 text-sm-right text-muted">
          本站由 <a href="https://github.com/getpelican/pelican" target="_blank">Pelican 生成</a> 后续 by <a href="https://github.com/njcx" target="_blank">nJcx</a>
        </p>
      </div>
    </div>
  </footer>
</body>

</html>